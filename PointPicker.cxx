#include <vtkActor.h>
#include <vtkInteractorStyleTrackballCamera.h>
#include <vtkNamedColors.h>
#include <vtkNew.h>
#include <vtkObjectFactory.h>
#include <vtkPointPicker.h>
#include <vtkPolyDataMapper.h>
#include <vtkRegularPolygonSource.h>
#include <vtkProperty.h>
#include <vtkRenderWindow.h>
#include <vtkRenderWindowInteractor.h>
#include <vtkRenderer.h>
#include <vtkRendererCollection.h>
#include <vtkSphereSource.h>
#include <vtkSmartPointer.h>
#include <vtkRenderWindow.h>
#include <vtkRenderer.h>
#include <vtkRenderWindowInteractor.h>
#include <vtkInteractorStyleTrackballCamera.h>
#include <vtkPoints.h>
#include <vtkCellArray.h>
#include <vtkPolyData.h>
#include <vtkLineSource.h>
#include <vtkPicker.h>
#include <vtkTextActor.h>
#include <vtkTextWidget.h>
#include <vtkTextProperty.h>
#include <vtkTextRepresentation.h>
#include <vtkNamedColors.h>
#include <vtkActor.h>
#include <QWidget>
#include <vtkCommand.h>
#include <vtkCoordinate.h>
#include <vtkNamedColors.h>
#include <vtkNew.h>
#include <vtkPolyDataMapper.h>
#include <vtkProperty.h>
#include <vtkRenderWindow.h>
#include <vtkRenderWindowInteractor.h>
#include <vtkRenderer.h>
#include <vtkSphereSource.h>
#include <vtkTextActor.h>
#include <vtkTextProperty.h>
#include <vtkTextRepresentation.h>
#include <vtkTextWidget.h>
#include <string>
#include <sstream>
#include <iostream>
#include <fstream>
#include< stdio.h >
#include <vtkTexturedButtonRepresentation2D.h>
#include <vtkPNGReader.h>
#include <vtkButtonWidget.h>
#include <vtkImageData.h>
#include <vtkTexture.h>
#include <vtkNamedColors.h>
#include <vtkImageCanvasSource2D.h>
#include <vtkImageData.h>
#include <vtkImageDataGeometryFilter.h>
#include <QVTKOpenGLNativeWidget.h>
#include <vtkActor.h>
#include <vtkDataSetMapper.h>
#include <vtkDoubleArray.h>
#include <vtkGenericOpenGLRenderWindow.h>
#include <vtkPointData.h>
#include <vtkProperty.h>
#include <vtkRenderer.h>
#include <vtkSphereSource.h>
#include <vtkTubeFilter.h>
#include <QApplication>
#include <QDockWidget>
#include <QGridLayout>
#include <QLabel>
#include <QMainWindow>
#include <QPointer>
#include <QPushButton>
#include <QVBoxLayout>
#include <QObject>
#include <vtkTransform.h>
#include <vtkTransformPolyDataFilter.h>
#include <cmath>
#include <cstdlib>
#include <random>
#include <QWidget>
#include <vtkSmartPointer.h>
#include <vtkRenderWindow.h>

#include <QtCore/QObject>
#include <QtCore/QDebug>
#include <QtWidgets/QApplication>
#include <QtWidgets/QPushButton>
#include <QLineEdit>
#include <QInputDialog>
#include <QComboBox>
#include <QSpinBox>
#include <vtkActor.h>
#include <vtkInteractorStyleTrackballCamera.h>
#include <vtkNamedColors.h>
#include <vtkNew.h>
#include <vtkObjectFactory.h>
#include <vtkPointPicker.h>
#include <vtkPolyDataMapper.h>
#include <vtkProperty.h>
#include <vtkRenderWindow.h>
#include <vtkRenderWindowInteractor.h>
#include <vtkRenderer.h>
#include <vtkRendererCollection.h>
#include <vtkSphereSource.h>
#include <vtkSmartPointer.h>
#include <vtkRenderWindow.h>
#include <vtkRenderer.h>
#include <vtkRenderWindowInteractor.h>
#include <vtkInteractorStyleTrackballCamera.h>
#include <vtkPolyDataMapper.h>
#include <vtkActor.h>
#include <vtkProperty.h>
#include <vtkPoints.h>
#include <vtkCellArray.h>
#include <vtkPolyData.h>
#include <vtkLineSource.h>
#include <vtkPicker.h>
#include <vtkTextActor.h>
#include <vtkTextWidget.h>
#include <vtkTextProperty.h>
#include <vtkTextRepresentation.h>
#include <vtkNamedColors.h>
#include <vtkActor.h>
#include <QWidget>
#include <vtkCommand.h>
#include <vtkCoordinate.h>
#include <vtkNamedColors.h>
#include <vtkNew.h>
#include <vtkPolyDataMapper.h>
#include <vtkProperty.h>
#include <vtkRenderWindow.h>
#include <vtkRenderWindowInteractor.h>
#include <vtkRenderer.h>
#include <vtkSphereSource.h>
#include <vtkTextActor.h>
#include <vtkTextProperty.h>
#include <vtkTextRepresentation.h>
#include <vtkTextWidget.h>
#include <string>
#include <sstream>
#include <iostream>
#include <fstream>
#include< stdio.h >
#include <vtkTexturedButtonRepresentation2D.h>
#include <vtkPNGReader.h>
#include <vtkButtonWidget.h>
#include <vtkImageData.h>
#include <vtkTexture.h>
#include <vtkImageViewer2.h>
#include <vtkNamedColors.h>
#include <vtkImageCanvasSource2D.h>
#include <vtkImageData.h>
#include <vtkImageDataGeometryFilter.h>
#include <QVTKOpenGLNativeWidget.h>
#include <vtkActor.h>
#include <vtkDataSetMapper.h>
#include <vtkDoubleArray.h>
#include <vtkGenericOpenGLRenderWindow.h>
#include <vtkPointData.h>
#include <vtkProperty.h>
#include <vtkRenderer.h>
#include <vtkSphereSource.h>
#include <vtkTubeFilter.h>
#include <QApplication>
#include <QDockWidget>
#include <QGridLayout>
#include <QLabel>
#include <QMainWindow>
#include <QPointer>
#include <QPushButton>
#include <QVBoxLayout>
#include <QObject>
#include <vtkHexahedron.h>
#include <QTextEdit>

#include <vtkActor.h>
#include <vtkCellArray.h>
#include <vtkCellData.h>
#include <vtkDoubleArray.h>
#include <vtkNamedColors.h>
#include <vtkNew.h>
#include <vtkRegularPolygonSource.h>
#include <vtkPoints.h>
#include <vtkPolyData.h>
#include <vtkPolyDataMapper.h>
#include <vtkPolyLine.h>
#include <vtkProperty.h>
#include <vtkRenderWindow.h>
#include <vtkRenderWindowInteractor.h>
#include <vtkRenderer.h>

#include <cmath>
#include <cstdlib>
#include <random>
#include <QWidget>
#include <vtkSmartPointer.h>
#include <vtkRenderWindow.h>

#include <QtCore/QObject>
#include <QtCore/QDebug>
#include <QtWidgets/QApplication>
#include <QtWidgets/QPushButton>
#include <QLineEdit>
#include <QInputDialog>
#include <QComboBox>
#include <QSpinBox>
#include <vtkActor.h>
#include <vtkCamera.h>
#include <vtkCellArray.h>
#include <vtkDataSetMapper.h>
#include <vtkHexahedron.h>
#include <vtkNamedColors.h>
#include <vtkNew.h>
#include <vtkPoints.h>
#include <vtkProperty.h>
#include <vtkRenderWindow.h>
#include <vtkRenderWindowInteractor.h>
#include <vtkRenderer.h>
#include <vtkUnstructuredGrid.h>
#include <cmath>
#include <set>
#include <QtWidgets/QFormLayout>
#include <QMessageBox>



using namespace std;
//__________Initializing some global variables___________________//
bool widget = 0;
set<string>Shapes_drawn;   //Store drawn shapes
std::string last_shape;
double picked[3];
double picked2[3] = {};
double picked3[3] = {};
double Circle_center[3] = {};
double RegPolyg_center[3] = {};
double Ellipse_center[3] = {};
double Arc_center[3] = {};
double line_center[3] = {};
double polygon_center[3] = {};
double polyline_center[3] = {};
double x = 0, y = 0, z = 0, z2 = 0, x2 = 0, y2 = 0;
double x3, y3, z3 = 0;
bool flag = 0;

int LineWidth = 3;

double ArcR;

char LineColor[100];
char CircleColor[100];
char EllipseColor[100];
char ArcColor[100];
char RegPolygonColor[100];
char PolylineColor[100];
char PolygonColor[100];
char SphereColor[100];
char EllipsoidColor[100];
char CubeColor[100];
int countIsPolygon = 0;
int startAngle = 0;
int endAngle = 0;
double r, sa, ea = 0.0;
double arcR = 3;
double arcStart = 0;
double arcEnd = 90;
bool FlagLineWriteFirstTime = 1;

// bools to know if shape is drawn or deleted




//_______________________________________________________________//

vtkNew<vtkPointPicker> pointPicker;
//_____________Empty set of points to delete figure_______________//
vtkSmartPointer<vtkPoints> Empty_points = vtkSmartPointer<vtkPoints>::New();
//________________________________________________________________//


//_____________________Line source,actor,mapper for each shape________________________________//

//Line
vtkSmartPointer<vtkLineSource> lineSource = vtkSmartPointer<vtkLineSource>::New();
vtkSmartPointer<vtkPolyDataMapper> mapper = vtkSmartPointer<vtkPolyDataMapper>::New();
vtkSmartPointer<vtkActor> actor = vtkSmartPointer<vtkActor>::New();
vtkSmartPointer<vtkPoints> points = vtkSmartPointer<vtkPoints>::New();

double LinePointsArray[2][3];

//Circle
vtkSmartPointer<vtkLineSource> Circle_lineSource = vtkSmartPointer<vtkLineSource>::New();
vtkSmartPointer<vtkPolyDataMapper> Circle_mapper = vtkSmartPointer<vtkPolyDataMapper>::New();
vtkSmartPointer<vtkActor> Circle_actor = vtkSmartPointer<vtkActor>::New();
double CirclePointsArray[2][3];
//Ellipse
vtkSmartPointer<vtkLineSource> Ellipse_lineSource = vtkSmartPointer<vtkLineSource>::New();
vtkSmartPointer<vtkPolyDataMapper> Ellipse_mapper = vtkSmartPointer<vtkPolyDataMapper>::New();
vtkSmartPointer<vtkActor> Ellipse_actor = vtkSmartPointer<vtkActor>::New();
double EllipsePointsArray[3][3];
//Regpolygon
vtkSmartPointer<vtkLineSource> Regpolygon_linesource = vtkSmartPointer<vtkLineSource>::New();
vtkSmartPointer<vtkPolyDataMapper> Regpolygon_mapper = vtkSmartPointer<vtkPolyDataMapper>::New();
vtkSmartPointer<vtkActor> Regpolygon_actor = vtkSmartPointer<vtkActor>::New();
double RegPolygonPointsArray[100][3];
//Polyline
vtkSmartPointer<vtkLineSource> Polyline_lineSource = vtkSmartPointer<vtkLineSource>::New();
vtkSmartPointer<vtkPolyDataMapper> Polyline_mapper = vtkSmartPointer<vtkPolyDataMapper>::New();
vtkSmartPointer<vtkActor> Polyline_actor = vtkSmartPointer<vtkActor>::New();
double PolylinePointsArray[100][3];
//Polygon
vtkSmartPointer<vtkLineSource> Polygon_lineSource = vtkSmartPointer<vtkLineSource>::New();
vtkSmartPointer<vtkPolyDataMapper> Polygon_mapper = vtkSmartPointer<vtkPolyDataMapper>::New();
vtkSmartPointer<vtkActor> Polygon_actor = vtkSmartPointer<vtkActor>::New();
double PolygonPointsArray[100][3];
//Arc
vtkSmartPointer<vtkLineSource> Arc_lineSource = vtkSmartPointer<vtkLineSource>::New();
vtkSmartPointer<vtkPolyDataMapper> Arc_mapper = vtkSmartPointer<vtkPolyDataMapper>::New();
vtkSmartPointer<vtkActor> Arc_actor = vtkSmartPointer<vtkActor>::New();
double ArcPointsArray[3];

//Star
vtkSmartPointer<vtkLineSource> Star_lineSource = vtkSmartPointer<vtkLineSource>::New();
vtkSmartPointer<vtkPolyDataMapper> Star_mapper = vtkSmartPointer<vtkPolyDataMapper>::New();
vtkSmartPointer<vtkActor> Star_actor = vtkSmartPointer<vtkActor>::New();



//Rossette
vtkSmartPointer<vtkLineSource> Rossette_lineSource = vtkSmartPointer<vtkLineSource>::New();
vtkSmartPointer<vtkPolyDataMapper> Rossette_mapper = vtkSmartPointer<vtkPolyDataMapper>::New();
vtkSmartPointer<vtkActor> Rossette_actor = vtkSmartPointer<vtkActor>::New();

//Sphere
vtkSmartPointer<vtkLineSource> Sphere_LineSource = vtkSmartPointer<vtkLineSource>::New();
vtkSmartPointer<vtkPolyDataMapper> Sphere_Mapper = vtkSmartPointer<vtkPolyDataMapper>::New();
vtkSmartPointer<vtkActor> Sphere_Actor = vtkSmartPointer<vtkActor>::New();
vtkSmartPointer<vtkCellArray> Sphere_Triangles = vtkSmartPointer<vtkCellArray>::New();
double SpherePointsArray[2][3];

//Cube
vtkSmartPointer<vtkLineSource> Cube_LineSource = vtkSmartPointer<vtkLineSource>::New();
vtkSmartPointer<vtkPolyDataMapper> Cube_Mapper = vtkSmartPointer<vtkPolyDataMapper>::New();
vtkSmartPointer<vtkActor> Cube_Actor = vtkSmartPointer<vtkActor>::New();
vtkSmartPointer<vtkCellArray> Cube_Triangles = vtkSmartPointer<vtkCellArray>::New();
double CubePointsArray[2][3];

//Ellipsoid
vtkSmartPointer<vtkLineSource> Ellipsoid_LineSource = vtkSmartPointer<vtkLineSource>::New();
vtkSmartPointer<vtkPolyDataMapper> Ellipsoid_Mapper = vtkSmartPointer<vtkPolyDataMapper>::New();
vtkSmartPointer<vtkActor> Ellipsoid_Actor = vtkSmartPointer<vtkActor>::New();
vtkSmartPointer<vtkCellArray> Ellipsoid_Triangles = vtkSmartPointer<vtkCellArray>::New();
double EllipsoidPointsArray[3][3];



//_____________________________________________________________________________________________//


vtkSmartPointer<vtkRenderer> renderer = vtkSmartPointer<vtkRenderer>::New();
vtkSmartPointer<vtkGenericOpenGLRenderWindow> renderWindow = vtkSmartPointer<vtkGenericOpenGLRenderWindow>::New();
vtkNew<vtkRenderWindowInteractor> renderWindowInteractor;
// vtkSmartPointer<vtkRenderWindow> renderWindow = vtkSmartPointer<vtkRenderWindow>::New();
std::stringstream ss;
vtkSmartPointer <vtkTextWidget> textWidget = vtkSmartPointer<vtkTextWidget>::New();
vtkSmartPointer<vtkTextActor> textActor = vtkSmartPointer<vtkTextActor>::New();

vtkNew<vtkNamedColors> colors;
vtkNew<vtkNamedColors> namedColors;
string pt;
string pt2;

bool polyL = false;
bool Line = true;
bool regpoly = false;
bool clearPolyLine = false;
bool circle = false;
int NumSides = 5;
float Scale_factor = 1;
int countPolyLinePoints = 0;


int countIsLine = 0;
bool isCircle = 0;
bool isEllipse = 0;
bool isArc = 0;
bool isRegularPolygon = 0;
bool isPolygon = 0;
bool isPolyline = 0;
bool isLine = 1;
bool isSphere = 0;
bool isEllipsoid = 0;
bool isCube = 0;
double pointsArray[100][3];
//________________________Some Transformation Parameters_____________________//
double Translation_x = 0;
double Translation_y = 0;
double Rotation_angle = 0;
double Shearing_x = 0;
double Scale_x = 0;
double Scale_y = 0;
//___________________________________________________________________________//

/////////////////////////////////////////Functions used by classes////////////////////////
//set the first point of the line
//void SetFirstPoint() {
//
//	//lineSource->SetPoint1(picked2[0], picked2[1], picked2[2]);
//	return;
//}

//set the second point of the line
void SetSecondPoint() {


	//lineSource->SetPoint2(picked[0], picked[1], picked[2]);
	//lineSource->Modified();
	//lineSource->Update();
	for (int i = 0; i < 2; i++) {

		for (int j = 0; j < 3; j++) {
			LinePointsArray[i][j] = 0.0;

		}
	}
	for (int i = 0; i < 2; i++) {
		if (i == 0) {
			LinePointsArray[i][0] = picked2[0];
			LinePointsArray[i][1] = picked2[1];
			LinePointsArray[i][2] = picked2[2];
		}
		if (i == 1) {
			LinePointsArray[i][0] = picked[0];
			LinePointsArray[i][1] = picked[1];
			LinePointsArray[i][2] = picked[2];
		}
	}
}


void InsertPolyPoint() {
	points->InsertNextPoint(picked[0], picked[1], picked[2]);
	std::cout << "Picked value of polyline: " << picked[0] << " " << picked[1] << " "
		<< picked[2] << std::endl;

}

void Set_line_shape(vtkLineSource* Shape_line, vtkPoints* Shape_points, vtkPolyDataMapper* Shape_mapper, vtkActor* Shape_actor, vtkRenderer* renderer)
{
	Shape_line->SetPoints(Shape_points);

	if (isCube) {
		vtkSmartPointer<vtkPolyData> polyData = vtkSmartPointer<vtkPolyData>::New();
		polyData->SetLines(Shape_line->GetOutput()->GetLines());
	}
	Shape_mapper->SetInputConnection(Shape_line->GetOutputPort());
	Shape_mapper->Update();
	Shape_actor->SetMapper(Shape_mapper);
	Shape_actor->GetProperty()->SetColor(1.0, 0.0, 0.0);   //Have to change this default color
	Shape_actor->GetProperty()->SetLineWidth(3.0);

	renderer->AddActor(Shape_actor);

}
int counterPoly = -1;
int counterPolygon = -1;
void Draw_Polyline() {
	if (counterPoly == -1) {
		for (int i = 0; i < sizeof(pointsArray)[0]; i++) {

			for (int j = 0; j < sizeof(pointsArray)[1]; j++) {
				pointsArray[i][j] = 0.0;

			}
		}
	}

	vtkSmartPointer<vtkPoints> points = vtkSmartPointer<vtkPoints>::New();
	counterPoly++;
	countIsLine = 1;
	//points->InsertNextPoint(picked[0], picked[1], 0);
	//vtkSmartPointer<vtkPoints> point1 = vtkSmartPointer<vtkPoints>::New();
	////point1=points->GetPoint(0);

	//vtkSmartPointer<vtkPoints> newPoints = vtkSmartPointer<vtkPoints>::New();
	//newPoints->DeepCopy(points);

	pointsArray[counterPoly][0] = picked[0];
	pointsArray[counterPoly][1] = picked[1];
	pointsArray[counterPoly][2] = picked[2];
	//pointsArray[i].Take(point1);

	for (int j = 0; j <= counterPoly; j++) {
		points->InsertNextPoint(pointsArray[j][0], pointsArray[j][1], pointsArray[j][2]);

	}
	//lineSource->SetPoints(points);
	//mapper->SetInputConnection(lineSource->GetOutputPort());
	//mapper->Update();
	//actor->SetMapper(mapper);
	////actor->GetProperty()->SetColor(LineColor);
	//renderer->AddActor(actor);
	//renderWindow->AddRenderer(renderer);
	Set_line_shape(Polyline_lineSource, points, Polyline_mapper, Polyline_actor, renderer);
	renderWindow->AddRenderer(renderer);

	if (counterPoly == 0) {
		for (int i = 0; i < sizeof(PolylinePointsArray)[0]; i++) {

			for (int j = 0; j < sizeof(PolylinePointsArray)[1]; j++) {
				PolylinePointsArray[i][j] = 0.0;

			}
		}

	}
	for (int i = 0; i <= counterPoly; i++) {
		PolylinePointsArray[i][0] = pointsArray[i][0];
		PolylinePointsArray[i][1] = pointsArray[i][1];
		PolylinePointsArray[i][2] = pointsArray[i][2];
	}
	/*renderWindowInteractor->SetRenderWindow(renderWindow);*/


}

void Draw_Polygon() {

	if (counterPolygon == -1) {
		for (int i = 0; i < sizeof(pointsArray)[0]; i++) {

			for (int j = 0; j < sizeof(pointsArray)[1]; j++) {
				pointsArray[i][j] = 0.0;

			}
		}
	}
	vtkSmartPointer<vtkPoints> points = vtkSmartPointer<vtkPoints>::New();
	counterPolygon++;
	countIsPolygon = 1;
	//points->InsertNextPoint(picked[0], picked[1], 0);
	//vtkSmartPointer<vtkPoints> point1 = vtkSmartPointer<vtkPoints>::New();
	////point1=points->GetPoint(0);

	//vtkSmartPointer<vtkPoints> newPoints = vtkSmartPointer<vtkPoints>::New();
	//newPoints->DeepCopy(points);

	pointsArray[counterPolygon][0] = picked[0];
	pointsArray[counterPolygon][1] = picked[1];
	pointsArray[counterPolygon][2] = picked[2];
	//pointsArray[i].Take(point1);

	for (int j = 0; j <= counterPolygon; j++) {
		/*if ((counterPolygon != 0) && j==counterPolygon-1) {
			pointsArray[counterPolygon][0] = 0;
			pointsArray[counterPolygon][1] = 0;
			pointsArray[counterPolygon][2] = 0;
		}*/
		points->InsertNextPoint(pointsArray[j][0], pointsArray[j][1], pointsArray[j][2]);
		if (j == counterPolygon) {
			points->InsertNextPoint(pointsArray[0][0], pointsArray[0][1], pointsArray[0][2]);
		}
	}

	Set_line_shape(Polygon_lineSource, points, Polygon_mapper, Polygon_actor, renderer);

	//lineSource->SetPoints(points);
	//mapper->SetInputConnection(lineSource->GetOutputPort());
		//mapper->Update();
	//actor->SetMapper(mapper);
	if (counterPolygon == 0) {
		for (int i = 0; i < sizeof(PolygonPointsArray)[0]; i++) {

			for (int j = 0; j < sizeof(PolygonPointsArray)[1]; j++) {
				PolygonPointsArray[i][j] = 0.0;

			}
		}

	}

	//renderer->AddActor(actor);
	for (int i = 0; i <= counterPolygon; i++) {

		PolygonPointsArray[i][0] = pointsArray[i][0];
		PolygonPointsArray[i][1] = pointsArray[i][1];
		PolygonPointsArray[i][2] = pointsArray[i][2];
	}
	renderWindow->AddRenderer(renderer);
	renderWindow->Render();

}




//Linear Interpolation to get set of points representing the line
void Draw_Line()
{
	vtkSmartPointer<vtkPoints> line_points = vtkSmartPointer<vtkPoints>::New();
	int number_of_points = 120;
	for (int i = 0; i <= number_of_points; i++)
	{
		double t = (double)i / (double)(number_of_points);
		double x = picked2[0] + t * (picked3[0] - picked2[0]);
		double y = picked2[1] + t * (picked3[1] - picked2[1]);
		double z = 0;
		line_points->InsertNextPoint(x, y, z);
	}

	Set_line_shape(lineSource, line_points, mapper, actor, renderer);
}

void Draw_Circle()
{
	double Raduis = sqrt(pow((picked[0] - picked2[0]), 2.0) + pow(picked[1] - picked2[1], 2.0));
	vtkSmartPointer<vtkPoints> Circle_points = vtkSmartPointer<vtkPoints>::New();
	int number_of_points = 120;
	lineSource->SetResolution(number_of_points);  //determines the quality of the generated line or polyline, with higher values of number_of_points leading to smoother and more precise lines.
	for (int i = 0; i <= number_of_points; i++)
	{
		double t_parameter = static_cast<double>(i) / number_of_points;   // division is performed using floating-point arithmetic rather than integer division.
		double x_circle = Scale_factor * (picked2[0] + Raduis * cos(2 * vtkMath::Pi() * t_parameter));
		double y_circle = Scale_factor * (picked2[1] + Raduis * sin(2 * vtkMath::Pi() * t_parameter));
		Circle_points->InsertNextPoint(x_circle, y_circle, 0.0);

	}

	Set_line_shape(Circle_lineSource, Circle_points, Circle_mapper, Circle_actor, renderer);

	for (int i = 0; i < 2; i++) {

		for (int j = 0; j < 3; j++) {
			CirclePointsArray[i][j] = 0.0;

		}
	}


	for (int i = 0; i < 2; i++) {
		if (i == 0) {
			CirclePointsArray[i][0] = picked2[0];
			CirclePointsArray[i][1] = picked2[1];
			CirclePointsArray[i][2] = picked2[2];
		}
		if (i == 1) {
			CirclePointsArray[i][0] = picked[0];
			CirclePointsArray[i][1] = picked[1];
			CirclePointsArray[i][2] = picked[2];
		}
	}

}

void Draw_Ellipse()
{

	double SemiMajorAxis = sqrt(pow((picked[0] - picked2[0]), 2.0) + pow((picked[1] - picked2[1]), 2.0));
	cout << "Major " << SemiMajorAxis << " ";
	double SemiMinorAxis = sqrt(pow((picked3[0] - picked2[0]), 2.0) + pow((picked3[1] - picked2[1]), 2.0));
	cout << "Minor " << SemiMinorAxis << " ";
	double axisRatio = SemiMajorAxis / SemiMinorAxis;
	cout << "ratio " << axisRatio << " ";
	vtkSmartPointer<vtkPoints> Ellipse_points = vtkSmartPointer<vtkPoints>::New();
	int number_of_points = 120;
	lineSource->SetResolution(number_of_points);


	//if (axisRatio >= 1) {
	SemiMajorAxis = sqrt(pow((picked3[0] - picked2[0]), 2.0) + pow(picked3[1] - picked2[1], 2.0));
	SemiMinorAxis = sqrt(pow((picked[0] - picked2[0]), 2.0) + pow(picked[1] - picked2[1], 2.0));
	cout << "first if";
	//}
	/*if(axisRatio<1) {
		SemiMajorAxis = sqrt(pow((picked[0] - picked2[0]), 2.0) + pow(picked[1] - picked2[1], 2.0));
		SemiMinorAxis = sqrt(pow((picked3[0] - picked2[0]), 2.0) + pow(picked3[1] - picked2[1], 2.0));
		cout << "AxisRatio<1";
	}*/

	for (int j = 0; j <= number_of_points; j++)
	{
		double x_ellipse;
		double y_ellipse;

		double t_parameter = static_cast<double>(j) / number_of_points;



		x_ellipse = Scale_factor * (picked2[0] + SemiMajorAxis * cos(2 * vtkMath::Pi() * (t_parameter + 0.25)));   //0.25?
		y_ellipse = Scale_factor * (picked2[1] + SemiMinorAxis * sin(2 * vtkMath::Pi() * (t_parameter + 0.25)));


		/*else if (axisRatio > 1) {
			x_ellipse = picked2[0] + SemiMajorAxis * sin(2 * vtkMath::Pi() * t_parameter)* sin(vtkMath::Pi() / 2);
			y_ellipse = picked2[1] + SemiMinorAxis *cos(2 * vtkMath::Pi() * t_parameter)*cos( vtkMath::Pi() / 2);
		}*/
		Ellipse_points->InsertNextPoint(x_ellipse, y_ellipse, 0.0);

	}

	for (int i = 0; i < 3; i++) {

		for (int j = 0; j < 3; j++) {
			EllipsePointsArray[i][j] = 0.0;

		}
	}



	for (int i = 0; i < 3; i++) {

		if (i == 0) {
			EllipsePointsArray[i][0] = picked2[0];
			EllipsePointsArray[i][1] = picked2[1];
			EllipsePointsArray[i][2] = picked2[2];
		}
		if (i == 1) {
			EllipsePointsArray[i][0] = picked3[0];
			EllipsePointsArray[i][1] = picked3[1];
			EllipsePointsArray[i][2] = picked3[2];
		}
		if (i == 2) {
			EllipsePointsArray[i][0] = picked[0];
			EllipsePointsArray[i][1] = picked[1];
			EllipsePointsArray[i][2] = picked[2];
		}

	}
	Set_line_shape(Ellipse_lineSource, Ellipse_points, Ellipse_mapper, Ellipse_actor, renderer);
}



void Draw_Arc(double Start_angle = arcStart, double End_Angle = arcEnd, double rad=0.0)
{

	double raduis = sqrt(pow((picked[0] - picked2[0]), 2.0) + pow(picked[1] - picked2[1], 2.0));
	if (rad != 0) {
		raduis = rad;
	}
	/*if (flag == 1) {
		raduis = ArcPointsArray[0];

	}*/
	ArcR = raduis;
	cout << "Radius arc " << raduis;
	vtkSmartPointer<vtkPoints> Arc_points = vtkSmartPointer<vtkPoints>::New();
	int number_of_points = 120;
	lineSource->SetResolution(number_of_points);
	double Angle_increment = (End_Angle - Start_angle) / (number_of_points - 1);
	for (int i = 0; i < number_of_points; i++)
	{
		double Current_angle = Start_angle + Angle_increment * i;
		double x_arc = raduis * cos(vtkMath::RadiansFromDegrees(Current_angle));
		double y_arc = raduis * sin(vtkMath::RadiansFromDegrees(Current_angle));
		Arc_points->InsertNextPoint(x_arc, y_arc, 0.0);

	}

	Set_line_shape(Arc_lineSource, Arc_points, Arc_mapper, Arc_actor, renderer);
	renderWindow->Render();

	for (int i = 0; i < 3; i++) {


		ArcPointsArray[i] = 0.0;

	}

	for (int i = 0; i < 3; i++) {

		if (i == 0) {
			ArcPointsArray[i] = raduis;

		}
		if (i == 1) {
			ArcPointsArray[i] = Start_angle;

		}
		if (i == 2) {
			ArcPointsArray[i] = End_Angle;

		}

	}

}





void Draw_Regular_Polygon()
{
	vtkSmartPointer<vtkPoints> Regpolygon_points = vtkSmartPointer<vtkPoints>::New();
	int number_of_points = NumSides;
	lineSource->SetResolution(number_of_points);

	double Raduis_regpolygon = sqrt(pow((picked[0] - picked2[0]), 2.0) + pow(picked[1] - picked2[1], 2.0));

	double Angle_increment = 2 * vtkMath::Pi() / number_of_points;
	for (int point_indx = 0; point_indx <= number_of_points; point_indx++)
	{
		double Current_angle = Angle_increment * point_indx;
		double x_regpolygon = Scale_factor * (picked2[0] + Raduis_regpolygon * cos(Current_angle));
		double y_regpolygon = Scale_factor * (picked2[1] + Raduis_regpolygon * sin(Current_angle));
		Regpolygon_points->InsertNextPoint(x_regpolygon, y_regpolygon, 0.0);

	}
	Set_line_shape(Regpolygon_linesource, Regpolygon_points, Regpolygon_mapper, Regpolygon_actor, renderer);


	for (int i = 0; i < sizeof(RegPolygonPointsArray)[0]; i++) {

		for (int j = 0; j < sizeof(RegPolygonPointsArray)[1]; j++) {
			RegPolygonPointsArray[i][j] = 0.0;

		}
	}


	for (int i = 0; i < 2; i++) {
		if (i == 0) {
			RegPolygonPointsArray[i][0] = picked2[0];
			RegPolygonPointsArray[i][1] = picked2[1];
			RegPolygonPointsArray[i][2] = picked2[2];
		}
		if (i == 1) {
			RegPolygonPointsArray[i][0] = picked[0];
			RegPolygonPointsArray[i][1] = picked[1];
			RegPolygonPointsArray[i][2] = picked[2];
		}
	}
}

void DrawSphere() {

	vtkSmartPointer<vtkPoints> Sphere_Points = vtkSmartPointer<vtkPoints>::New();

	// Create a set of points that define the vertices of the sphere
	double cx = picked2[0];
	double cy = picked2[1];
	double cz = picked2[2];

	double radius = sqrt(pow((picked[0] - picked2[0]), 2.0) + pow(picked[1] - picked2[1], 2.0) + pow(picked[2] - picked2[2], 2.0));

	const int nPhi = 50;
	const int nTheta = 50;
	for (int i = 0; i <= nTheta; i++) {
		double theta = i * vtkMath::Pi() / nTheta;
		for (int j = 0; j <= nPhi; j++) {
			double phi = j * 2 * vtkMath::Pi() / nPhi;
			double x = cx + radius * sin(theta) * cos(phi);
			double y = cy + radius * sin(theta) * sin(phi);
			double z = cz + radius * cos(theta);
			Sphere_Points->InsertNextPoint(x, y, z);
		}
	}

	// Create a set of triangles that define the surface of the sphere

	for (int i = 0; i < nTheta; i++) {
		for (int j = 0; j < nPhi; j++) {
			int p0 = i * (nPhi + 1) + j;
			int p1 = (i + 1) * (nPhi + 1) + j;
			int p2 = i * (nPhi + 1) + (j + 1);
			int p3 = (i + 1) * (nPhi + 1) + (j + 1);
			vtkSmartPointer<vtkIdList> triangle = vtkSmartPointer<vtkIdList>::New();
			triangle->InsertNextId(p0);
			triangle->InsertNextId(p1);
			triangle->InsertNextId(p3);
			Sphere_Triangles->InsertNextCell(triangle);
			triangle->Reset();
			triangle->InsertNextId(p0);
			triangle->InsertNextId(p3);
			triangle->InsertNextId(p2);
			Sphere_Triangles->InsertNextCell(triangle);
		}
	}
	for (int i = 0; i < 2; i++) {

		for (int j = 0; j < 3; j++) {
			SpherePointsArray[i][j] = 0.0;

		}
	}


	for (int i = 0; i < 2; i++) {
		if (i == 0) {
			SpherePointsArray[i][0] = picked2[0];
			SpherePointsArray[i][1] = picked2[1];
			SpherePointsArray[i][2] = picked2[2];
		}
		if (i == 1) {
			SpherePointsArray[i][0] = picked[0];
			SpherePointsArray[i][1] = picked[1];
			SpherePointsArray[i][2] = picked[2];
		}
	}
	Set_line_shape(Sphere_LineSource, Sphere_Points, Sphere_Mapper, Sphere_Actor, renderer);
	
}
void DrawCube() {

	vtkSmartPointer<vtkPoints> Cube_Points = vtkSmartPointer<vtkPoints>::New();

	double length = fabs(picked2[0] - picked[0]);

	double cubeVertices[16][3] = { {picked2[0]			,				picked2[1]			,			picked2[2]},
									{picked2[0] + length	,				picked2[1]			,			picked2[2]},
									{picked2[0] + length	,			picked2[1] + length		,			picked2[2]},
									{picked2[0]			,			picked2[1] + length		,			picked2[2]},
									{picked2[0]			,				picked2[1]			,			picked2[2]},
									{picked2[0]			,				picked2[1]			,			picked2[2] + length},
									{picked2[0] + length	,				picked2[1]			,			picked2[2] + length},
									{picked2[0] + length	,				picked2[1]			,			picked2[2]},
									{picked2[0] + length	,				picked2[1]			,			picked2[2] + length},
									{picked2[0] + length	,			picked2[1] + length		,			picked2[2] + length},
									{picked2[0] + length	,			picked2[1] + length		,			picked2[2]},
									{picked2[0] + length	,			picked2[1] + length		,			picked2[2] + length},
									{picked2[0]			,			picked2[1] + length		,			picked2[2] + length},
									{picked2[0]			,			picked2[1] + length		,			picked2[2]},
									{picked2[0]			,			picked2[1] + length		,			picked2[2] + length},
									{picked2[0]			,				picked2[1]			,			picked2[2] + length} };

	for (int i = 0; i < 16; i++) {
		Cube_Points->InsertNextPoint(cubeVertices[i]);
	}

	vtkSmartPointer<vtkCellArray> Cube_Lines = vtkSmartPointer<vtkCellArray>::New();
	Cube_Lines->InsertNextCell(5);
	Cube_Lines->InsertCellPoint(0);
	Cube_Lines->InsertCellPoint(1);
	Cube_Lines->InsertCellPoint(2);
	Cube_Lines->InsertCellPoint(3);
	Cube_Lines->InsertCellPoint(0);

	Cube_Lines->InsertNextCell(5);
	Cube_Lines->InsertCellPoint(4);
	Cube_Lines->InsertCellPoint(5);
	Cube_Lines->InsertCellPoint(6);
	Cube_Lines->InsertCellPoint(7);
	Cube_Lines->InsertCellPoint(4);

	Cube_Lines->InsertNextCell(4);
	Cube_Lines->InsertCellPoint(0);
	Cube_Lines->InsertCellPoint(4);
	Cube_Lines->InsertCellPoint(7);
	Cube_Lines->InsertCellPoint(3);

	Cube_Lines->InsertNextCell(4);
	Cube_Lines->InsertCellPoint(1);
	Cube_Lines->InsertCellPoint(5);
	Cube_Lines->InsertCellPoint(6);
	Cube_Lines->InsertCellPoint(2);

	//vtkSmartPointer<vtkLineSource> Cube_LineSource = vtkSmartPointer<vtkLineSource>::New();
	//Cube_LineSource->SetPoints(Cube_Points);
	//Cube_LineSource->SetLines(Cube_Lines);
	for (int i = 0; i < 2; i++) {

		for (int j = 0; j < 3; j++) {
			CubePointsArray[i][j] = 0.0;

		}
	}


	for (int i = 0; i < 2; i++) {
		if (i == 0) {
			CubePointsArray[i][0] = picked2[0];
			CubePointsArray[i][1] = picked2[1];
			CubePointsArray[i][2] = picked2[2];
		}
		if (i == 1) {
			CubePointsArray[i][0] = picked[0];
			CubePointsArray[i][1] = picked[1];
			CubePointsArray[i][2] = picked[2];
		}
	}
	Set_line_shape(Cube_LineSource, Cube_Points, Cube_Mapper, Cube_Actor, renderer);

}

void Draw_Ellipsoid() {

	vtkSmartPointer<vtkPoints> Ellipsoid_Points = vtkSmartPointer<vtkPoints>::New();
	double center[3] = { picked2[0], picked2[1], picked2[2] };

	// Define the semi-axes of the ellipsoid
	double a = sqrt(pow((picked3[0] - picked2[0]), 2.0) + pow(picked3[1] - picked2[1], 2.0));
	double b = sqrt(pow((picked[0] - picked2[0]), 2.0) + pow(picked[1] - picked2[1], 2.0));
	double c = (a+b)/2;

	// Define the number of points in the ellipsoid mesh
	int numPoints = 100;

	// Create the points for the ellipsoid
	for (int i = 0; i < numPoints; ++i) {
		double theta = i * 2.0 * vtkMath::Pi() / numPoints;
		for (int j = 0; j < numPoints; ++j) {
			double phi = j * vtkMath::Pi() / numPoints;
			double x = center[0] + a * sin(phi) * cos(theta);
			double y = center[1] + b * sin(phi) * sin(theta);
			double z = center[2] + c * cos(phi);
			Ellipsoid_Points->InsertNextPoint(x, y, z);
		}
	}

	// Create the cells (triangles) for the ellipsoid
	vtkSmartPointer<vtkCellArray> cells = vtkSmartPointer<vtkCellArray>::New();

	for (int i = 0; i < 3; i++) {

		for (int j = 0; j < 3; j++) {
			EllipsoidPointsArray[i][j] = 0.0;

		}
	}



	for (int i = 0; i < 3; i++) {

		if (i == 0) {
			EllipsoidPointsArray[i][0] = picked2[0];
			EllipsoidPointsArray[i][1] = picked2[1];
			EllipsoidPointsArray[i][2] = picked2[2];
		}
		if (i == 1) {
			EllipsoidPointsArray[i][0] = picked3[0];
			EllipsoidPointsArray[i][1] = picked3[1];
			EllipsoidPointsArray[i][2] = picked3[2];
		}
		if (i == 2) {
			EllipsoidPointsArray[i][0] = picked[0];
			EllipsoidPointsArray[i][1] = picked[1];
			EllipsoidPointsArray[i][2] = picked[2];
		}

	}


	Set_line_shape(Ellipsoid_LineSource, Ellipsoid_Points, Ellipsoid_Mapper, Ellipsoid_Actor, renderer);

}


/*
void Draw_Ellipsoid()
	{
		double Semi_AxisX = sqrt(pow((picked3[0] - picked2[0]), 2.0) + pow(picked3[1] - picked2[1], 2.0));
		double Semi_AxisY = sqrt(pow((picked[0] - picked2[0]), 2.0) + pow(picked[1] - picked2[1], 2.0));
		double Semi_AxisZ = 1;

		vtkSmartPointer<vtkPoints> Ellipsoid_points = vtkSmartPointer<vtkPoints>::New();
		int number_of_points = 120;
		lineSource->SetResolution(number_of_points);

		for (int j = 0; j <= number_of_points; j++)
		{
			double x_ellipse, y_ellipse, z_ellipse;

			double t_parameter = static_cast<double>(j) / number_of_points;

			x_ellipse = picked2[0] + Semi_AxisX * cos(2 * vtkMath::Pi() * t_parameter);
			y_ellipse = picked2[1] + Semi_AxisY * sin(2 * vtkMath::Pi() * t_parameter);
			z_ellipse = picked2[2] + Semi_AxisZ * cos(2 * vtkMath::Pi() * t_parameter);

			Ellipsoid_points->InsertNextPoint(x_ellipse, y_ellipse, z_ellipse);
		}

		Set_line_shape(Ellipsoid_LineSource, Ellipsoid_points, Ellipsoid_Mapper, Ellipsoid_Actor, renderer);
	}

	*/


bool ReadFile(char name[100]) {
	int i = 0;
	for (i; i < 101; i++) {
		if (name[i] == '\0')
		{
			break;
		}
	}
	name[i] = '.';
	name[i + 1] = 't';
	name[i + 2] = 'x';
	name[i + 3] = 't';
	name[i + 4] = '\0';

	int j = 0;

	while (name[j] != '\0') {

		cout << name[j];
		j++;
	}
	FILE* file;
	fopen_s(&file, name, "r");
	cout << "file to be read  " << file;
	if (file != NULL) {

		if (Shapes_drawn.find("Line") != Shapes_drawn.end()) {

			isLine = 1;
			isEllipse = 0;
			isArc = 0;
			isRegularPolygon = 0;
			isPolygon = 0;
			isPolyline = 0;
			isCircle = 0;
			picked[0] = 0;
			picked[1] = 0;
			picked[2] = 0;

			picked2[0] = 0;
			picked2[1] = 0;
			picked2[2] = 0;

			x, y, z, x2, y2, z2, x3, y3, z3 = 0;


			fscanf_s(file, "Line,(%lf,%lf,%lf),(%lf,%lf,%lf),%d,%s\n", &x, &y, &z, &x2, &y2, &z2, &LineWidth, LineColor, sizeof(LineColor));

			for (int i = 0; i < 3; i++) {
				if (i == 0) {
					picked3[i] = x2;
					picked2[i] = x;
				}
				if (i == 1) {
					picked3[i] = y2;
					picked2[i] = y;
				}
				if (i == 2) {
					picked3[i] = z2;
					picked2[i] = z;
				}
			}
			Draw_Line();
			SetSecondPoint();

			printf("x: %lf, y: %lf, z: %lf\n", x, y, z);
			printf("x2: %lf, y2: %lf, z2: %lf\n", x2, y2, z2);
			printf("LineWidth: %d\n", LineWidth);
			printf("LineColor: %s\n", LineColor);
			cout << "picked= " << picked[1] << "picked2= " << picked2[1] << endl;

		}
		if (Shapes_drawn.find("Circle") != Shapes_drawn.end()) {

			isLine = 0;
			isEllipse = 0;
			isArc = 0;
			isRegularPolygon = 0;
			isPolygon = 0;
			isPolyline = 0;
			isCircle = 1;
			picked[0] = 0;
			picked[1] = 0;
			picked[2] = 0;

			picked2[0] = 0;
			picked2[1] = 0;
			picked2[2] = 0;
			x, y, z, x2, y2, z2, x3, y3, z3 = 0;
			fscanf_s(file, "Circle,(%lf,%lf,%lf),(%lf,%lf,%lf),%d,%s\n", &x, &y, &z, &x2, &y2, &z2, &LineWidth, LineColor, sizeof(LineColor));

			for (int i = 0; i < 3; i++) {
				if (i == 0) {
					picked[i] = x2;
					picked2[i] = x;
				}
				if (i == 1) {
					picked[i] = y2;
					picked2[i] = y;
				}
				if (i == 2) {
					picked[i] = z2;
					picked2[i] = z;
				}
			}
			Draw_Circle();
		}
		if (Shapes_drawn.find("Ellipse") != Shapes_drawn.end()) {
			isLine = 0;
			isEllipse = 0;
			isArc = 0;
			isRegularPolygon = 0;
			isPolygon = 0;
			isPolyline = 0;
			isCircle = 1;
			picked[0] = 0;
			picked[1] = 0;
			picked[2] = 0;

			picked2[0] = 0;
			picked2[1] = 0;
			picked2[2] = 0;

			picked3[0] = 0;
			picked3[1] = 0;
			picked3[2] = 0;
			x, y, z, x2, y2, z2, x3, y3, z3 = 0;

			fscanf_s(file, "Ellipse,(%lf,%lf,%lf),(%lf,%lf,%lf),(%lf,%lf,%lf),%d,%s\n", &x, &y, &z, &x2, &y2, &z2, &x3, &y3, &z3, &LineWidth, LineColor, sizeof(LineColor));

			for (int i = 0; i < 3; i++) {
				if (i == 0) {
					picked[i] = x3;
					picked2[i] = x;
					picked3[i] = x2;
				}
				if (i == 1) {
					picked[i] = y3;
					picked2[i] = y;
					picked3[i] = y2;
				}
				if (i == 2) {
					picked[i] = z3;
					picked2[i] = z;
					picked3[i] = z2;
				}
			}
			Draw_Ellipse();
		}
		if (Shapes_drawn.find("Arc") != Shapes_drawn.end()) {
			isLine = 0;
			isEllipse = 0;
			isArc = 1;
			isRegularPolygon = 0;
			isPolygon = 0;
			isPolyline = 0;
			isCircle = 0;

			fscanf_s(file, "Arc,%lf,%lf,%lf,%d,%s\n", &x, &y, &z, &LineWidth, LineColor, sizeof(LineColor));



			ArcR = x;



			arcStart = y;



			arcEnd = z;


			Draw_Arc(arcStart, arcEnd, ArcR);
			flag = 1;
		}
		int num = 0;
		if (Shapes_drawn.find("Polyline") != Shapes_drawn.end()) {

			isLine = 0;
			isEllipse = 0;
			isArc = 0;
			isRegularPolygon = 0;
			isPolygon = 0;
			isPolyline = 1;
			isCircle = 0;

			picked[0] = 0;
			picked[1] = 0;
			picked[2] = 0;
			x, y, z, x2, y2, z2, x3, y3, z3 = 0;
			num = 0;
			fscanf_s(file, "Polyline,%d", &num);

			/*int xpolyl=0;
			int ypolyl=0;
			int zpolyl=0;*/

			for (int i = 0; i < num; i++) {
				fscanf_s(file, ",(%lf,%lf,%lf)", &x, &y, &z);
				picked[0] = x;
				picked[1] = y;
				picked[2] = z;
				if (i == 0) {
					counterPoly = -1;
				}
				Draw_Polyline();

				printf("Polyline x: %lf, y: %lf, z: %lf\n", x, y, z);

			}
			fscanf_s(file, ",%d,%s\n", &LineWidth, LineColor, sizeof(LineColor));
			renderWindow->Render();

		}
		printf("num: %d", num);

		printf("LineWidth: %d\n", LineWidth);
		printf("LineColor: %s\n", LineColor);
		cout << "picked= " << picked[1] << "picked2= " << picked2[1] << endl;
		//linestream << line;
		//linestream >> x >> y >> z;
		//if (counter ==1) {
		if (Shapes_drawn.find("Polygon") != Shapes_drawn.end()) {
			isLine = 0;
			isEllipse = 0;
			isArc = 0;
			isRegularPolygon = 0;
			isPolygon = 1;
			isPolyline = 0;
			isCircle = 0;

			picked[0] = 0;
			picked[1] = 0;
			picked[2] = 0;
			num = 0;
			x, y, z, x2, y2, z2, x3, y3, z3 = 0;
			fscanf_s(file, "Polygon,%d", &num);

			/*int xpolyl=0;
			int ypolyl=0;
			int zpolyl=0;*/

			for (int i = 0; i < num; i++) {
				fscanf_s(file, ",(%lf,%lf,%lf)", &x, &y, &z);
				picked[0] = x;
				picked[1] = y;
				picked[2] = z;
				if (i == 0) {
					counterPolygon = -1;
				}
				Draw_Polygon();

				printf("Polygon x: %lf, y: %lf, z: %lf\n", x, y, z);

			}
			fscanf_s(file, ",%d,%s\n", &LineWidth, LineColor, sizeof(LineColor));
			renderWindow->Render();

		}
		if (Shapes_drawn.find("Regular Polygon") != Shapes_drawn.end()) {

			isLine = 0;
			isEllipse = 0;
			isArc = 0;
			isRegularPolygon = 1;
			isPolygon = 0;
			isPolyline = 0;
			isCircle = 0;

			picked[0] = 0;
			picked[1] = 0;
			picked[2] = 0;

			picked2[0] = 0;
			picked2[1] = 0;
			picked2[2] = 0;
			num = 0;
			x, y, z, x2, y2, z2, x3, y3, z3 = 0;
			fscanf_s(file, "Regular Polygon,%d,(%lf,%lf,%lf),(%lf,%lf,%lf),%d,%s\n", &num, &x, &y, &z, &x2, &y2, &z2, &LineWidth, LineColor, sizeof(LineColor));

			for (int i = 0; i < 3; i++) {
				if (i == 0) {
					picked[i] = x2;
					picked2[i] = x;
				}
				if (i == 1) {
					picked[i] = y2;
					picked2[i] = y;
				}
				if (i == 2) {
					picked[i] = z2;
					picked2[i] = z;
				}
			}
			NumSides = num;
			Draw_Regular_Polygon();

		}
		if (Shapes_drawn.find("Ellipsoid") != Shapes_drawn.end()) {
			isLine = 0;
			isEllipse = 0;
			isArc = 0;
			isRegularPolygon = 0;
			isPolygon = 0;
			isPolyline = 0;
			isCircle = 1;
			picked[0] = 0;
			picked[1] = 0;
			picked[2] = 0;

			picked2[0] = 0;
			picked2[1] = 0;
			picked2[2] = 0;

			picked3[0] = 0;
			picked3[1] = 0;
			picked3[2] = 0;
			x, y, z, x2, y2, z2, x3, y3, z3 = 0;

			fscanf_s(file, "Ellipsoid,(%lf,%lf,%lf),(%lf,%lf,%lf),(%lf,%lf,%lf),%d,%s\n", &x, &y, &z, &x2, &y2, &z2, &x3, &y3, &z3, &LineWidth, LineColor, sizeof(LineColor));

			for (int i = 0; i < 3; i++) {
				if (i == 0) {
					picked[i] = x3;
					picked2[i] = x;
					picked3[i] = x2;
				}
				if (i == 1) {
					picked[i] = y3;
					picked2[i] = y;
					picked3[i] = y2;
				}
				if (i == 2) {
					picked[i] = z3;
					picked2[i] = z;
					picked3[i] = z2;
				}
			}
			Draw_Ellipsoid();
		}
		if (Shapes_drawn.find("Cube") != Shapes_drawn.end()) {



			fscanf_s(file, "Cube,(%lf,%lf,%lf),(%lf,%lf,%lf),%d,%s\n", &x, &y, &z, &x2, &y2, &z2, &LineWidth, LineColor, sizeof(LineColor));

			for (int i = 0; i < 3; i++) {
				if (i == 0) {
					picked[i] = x2;
					picked2[i] = x;
				}
				if (i == 1) {
					picked[i] = y2;
					picked2[i] = y;
				}
				if (i == 2) {
					picked[i] = z2;
					picked2[i] = z;
				}
			}
			DrawCube();

			printf("x: %lf, y: %lf, z: %lf\n", x, y, z);
			printf("x2: %lf, y2: %lf, z2: %lf\n", x2, y2, z2);
			printf("LineWidth: %d\n", LineWidth);
			printf("LineColor: %s\n", LineColor);
			cout << "picked= " << picked[1] << "picked2= " << picked2[1] << endl;

		}
		if (Shapes_drawn.find("Sphere") != Shapes_drawn.end()) {

			isLine = 0;
			isEllipse = 0;
			isArc = 0;
			isRegularPolygon = 0;
			isPolygon = 0;
			isPolyline = 0;
			isCircle = 1;
			picked[0] = 0;
			picked[1] = 0;
			picked[2] = 0;

			picked2[0] = 0;
			picked2[1] = 0;
			picked2[2] = 0;
			x, y, z, x2, y2, z2, x3, y3, z3 = 0;
			fscanf_s(file, "Sphere,(%lf,%lf,%lf),(%lf,%lf,%lf),%d,%s\n", &x, &y, &z, &x2, &y2, &z2, &LineWidth, LineColor, sizeof(LineColor));

			for (int i = 0; i < 3; i++) {
				if (i == 0) {
					picked[i] = x2;
					picked2[i] = x;
				}
				if (i == 1) {
					picked[i] = y2;
					picked2[i] = y;
				}
				if (i == 2) {
					picked[i] = z2;
					picked2[i] = z;
				}
			}
			DrawSphere();
		}

	}

	fclose(file);



	// DrawLineOnce(); 
	return true;
}


bool  WriteFile(string name) {

	fstream my_file;
	my_file.open(name, ios::out);
	if (!my_file) {
		cout << "File not created!";
	}
	else {
		cout << "File created successfully!";
		if (Shapes_drawn.find("Line") != Shapes_drawn.end()) {
			my_file << "Line,";
			for (int i = 0; i < sizeof(LinePointsArray) / sizeof(LinePointsArray[0]); i++) {
				my_file << "(" << LinePointsArray[i][0] << "," << LinePointsArray[i][1] << "," << LinePointsArray[i][2] << "),";
			}
			my_file << LineWidth << "," << LineColor << endl;
		}if (Shapes_drawn.find("Circle") != Shapes_drawn.end()) {
			my_file << "Circle,";
			for (int i = 0; i < sizeof(CirclePointsArray) / sizeof(CirclePointsArray[0]); i++) {
				my_file << "(" << CirclePointsArray[i][0] << "," << CirclePointsArray[i][1] << "," << CirclePointsArray[i][2] << "),";
			}
			my_file << LineWidth << "," << LineColor << endl;
		}
		if (Shapes_drawn.find("Ellipse") != Shapes_drawn.end()) {
			my_file << "Ellipse,";
			for (int i = 0; i < sizeof(EllipsePointsArray) / sizeof(EllipsePointsArray[0]); i++) {
				my_file << "(" << EllipsePointsArray[i][0] << "," << EllipsePointsArray[i][1] << "," << EllipsePointsArray[i][2] << "),";
			}
			my_file << LineWidth << "," << LineColor << endl;
		}
		if (Shapes_drawn.find("Arc") != Shapes_drawn.end()) {
			my_file << "Arc,";

			my_file << ArcPointsArray[0] << "," << ArcPointsArray[1] << "," << ArcPointsArray[2] << ",";

			my_file << LineWidth << "," << LineColor << endl;
		}
		if (Shapes_drawn.find("Polyline") != Shapes_drawn.end()) {
			int Polyline = counterPoly + 1;
			my_file << "Polyline," << Polyline << ",";
			for (int i = 0; i < Polyline; i++) {
				/*if (PolylinePointsArray[i][0] == 0 && PolylinePointsArray[i][1] == 0 && PolylinePointsArray[i][2] == 0) {
					break;
				}*/
				my_file << "(" << PolylinePointsArray[i][0] << "," << PolylinePointsArray[i][1] << "," << PolylinePointsArray[i][2] << "),";
			}
			my_file << LineWidth << "," << LineColor << endl;
		}
		if (Shapes_drawn.find("Polygon") != Shapes_drawn.end()) {
			int Polygon = counterPolygon + 1;
			my_file << "Polygon," << Polygon << ",";
			for (int i = 0; i < Polygon; i++) {

				/*if (PolygonPointsArray[i][0] == 0 && PolygonPointsArray[i][1] == 0 && PolygonPointsArray[i][2] == 0) {
					break;
				}*/
				my_file << "(" << PolygonPointsArray[i][0] << "," << PolygonPointsArray[i][1] << "," << PolygonPointsArray[i][2] << "),";
			}
			my_file << LineWidth << "," << LineColor << endl;

		}
		if (Shapes_drawn.find("Regular Polygon") != Shapes_drawn.end()) {
			my_file << "Regular Polygon," << NumSides << ",";
			for (int i = 0; i < sizeof(RegPolygonPointsArray) / sizeof(RegPolygonPointsArray[0]); i++) {
				if (RegPolygonPointsArray[i][0] == 0 && RegPolygonPointsArray[i][1] == 0 && RegPolygonPointsArray[i][2] == 0) {
					break;
				}
				my_file << "(" << RegPolygonPointsArray[i][0] << "," << RegPolygonPointsArray[i][1] << "," << RegPolygonPointsArray[i][2] << "),";


			}
			my_file << LineWidth << "," << LineColor << endl;

		}
		if (Shapes_drawn.find("Ellipsoid") != Shapes_drawn.end()) {
			my_file << "Ellipsoid,";
			for (int i = 0; i < sizeof(EllipsoidPointsArray) / sizeof(EllipsoidPointsArray[0]); i++) {
				my_file << "(" << EllipsoidPointsArray[i][0] << "," << EllipsoidPointsArray[i][1] << "," << EllipsoidPointsArray[i][2] << "),";
			}
			my_file << LineWidth << "," << LineColor << endl;
		}

		if (Shapes_drawn.find("Cube") != Shapes_drawn.end()) {
			my_file << "Cube,";
			for (int i = 0; i < sizeof(CubePointsArray) / sizeof(CubePointsArray[0]); i++) {
				my_file << "(" << CubePointsArray[i][0] << "," << CubePointsArray[i][1] << "," << CubePointsArray[i][2] << "),";
			}
			my_file << LineWidth << "," << LineColor << endl;
		}

		if (Shapes_drawn.find("Sphere") != Shapes_drawn.end()) {
			my_file << "Sphere,";
			for (int i = 0; i < sizeof(SpherePointsArray) / sizeof(SpherePointsArray[0]); i++) {
				my_file << "(" << SpherePointsArray[i][0] << "," << SpherePointsArray[i][1] << "," << SpherePointsArray[i][2] << "),";
			}
			my_file << LineWidth << "," << LineColor << endl;
		}
		my_file.close();

	}

	return true;


}
void DrawPoint() {

	for (int i = 0; i < 2; i++) {
		if (i == 0) {
			ss << "x= ";
		}
		if (i == 1) {
			ss << "y= ";
		}
		ss << picked[i] << ", ";
	}
	pt = ss.str();
	ss.str("");



	vtkNew<vtkNamedColors> colors;


	renderWindow->AddRenderer(renderer);
	renderWindowInteractor->SetRenderWindow(renderWindow);


	do {
		vtkSmartPointer <vtkTextWidget> textWidget = vtkSmartPointer<vtkTextWidget>::New();
		widget = 1;


	} while (widget == 0);



	textActor->SetInput(pt.c_str());

	//textActor->SetInput(floatString2.c_str());
   //textActor->SetInput(to_string(floatString));
	textActor->GetTextProperty()->SetColor(colors->GetColor3d("White").GetData());
	vtkSmartPointer<vtkTextRepresentation> textRepresentation = vtkSmartPointer<vtkTextRepresentation>::New();
	// vtkSmartPointer<vtkRenderWindowInteractor> interactor = vtkSmartPointer<vtkRenderWindowInteractor>::New();
	textRepresentation->GetPositionCoordinate()->SetValue(0.15, 0.15);
	textRepresentation->GetPosition2Coordinate()->SetValue(0.6, 0.18);
	textWidget->SetRepresentation(textRepresentation);

	textWidget->SetInteractor(renderWindowInteractor);
	textWidget->SetTextActor(textActor);
	textWidget->SelectableOff();



	textWidget->On();
	renderWindow->Render();

	//renderWindowInteractor->Start();


	return;
}
//Delete shape function
void Delete_Shape(string selected_shape)
{




	if (selected_shape == "Circle")
	{
		Circle_lineSource->SetPoints(Empty_points);

	}
	else if (selected_shape == "Ellipse")
	{
		Ellipse_lineSource->SetPoints(Empty_points);
	}

	else if (selected_shape == "Polyline")
	{
		Polyline_lineSource->SetPoints(Empty_points);
	}

	else if (selected_shape == "Regular Polygon")
	{
		Regpolygon_linesource->SetPoints(Empty_points);

	}

	else if (selected_shape == "Polygon")
	{
		Polygon_lineSource->SetPoints(Empty_points);

	}
	else if (selected_shape == "Arc")
	{
		Arc_lineSource->SetPoints(Empty_points);


	}
	else if (selected_shape == "Line")
	{
		lineSource->SetPoints(Empty_points);
	}

	else if (selected_shape == "Sphere")
	{
		Sphere_LineSource->SetPoints(Empty_points);
	}
	else if (selected_shape == "Ellipsoid")
	{
		Ellipsoid_LineSource->SetPoints(Empty_points);
	}

	else if (selected_shape == "Cube")
	{
		Cube_LineSource->SetPoints(Empty_points);
	}

}

void change_width_shape(int width_shape, string selected_shape)
{
	//actor->GetProperty()->SetLineWidth(spinBox->value());
	if (selected_shape == "Circle")
	{
		Circle_actor->GetProperty()->SetLineWidth(width_shape);

	}
	else if (selected_shape == "Ellipse")
	{
		Ellipse_actor->GetProperty()->SetLineWidth(width_shape);
	}

	else if (selected_shape == "Polyline")
	{
		Polyline_actor->GetProperty()->SetLineWidth(width_shape);

	}

	else if (selected_shape == "Regular Polygon")
	{
		Regpolygon_actor->GetProperty()->SetLineWidth(width_shape);

	}

	else if (selected_shape == "Polygon")
	{
		Polygon_actor->GetProperty()->SetLineWidth(width_shape);

	}
	else if (selected_shape == "Arc")
	{
		Arc_actor->GetProperty()->SetLineWidth(width_shape);

	}
	else if (selected_shape == "Line")
	{
		actor->GetProperty()->SetLineWidth(width_shape);
	}

	else if (selected_shape == "Sphere")
	{
		Sphere_Actor->GetProperty()->SetLineWidth(width_shape);
	}

	else if (selected_shape == "Ellipsoid")
	{
		Ellipsoid_Actor->GetProperty()->SetLineWidth(width_shape);
	}
	else if (selected_shape == "Cube")
	{
		Cube_Actor->GetProperty()->SetLineWidth(width_shape);
	}



}

//Actor, colorcombobox
void change_color(QString color_chosen, string selected_shape)
{
	//Shape_actor->GetProperty()->SetColor(colors->GetColor3d(color_chosen.toStdString()).GetData());

	if (selected_shape == "Circle")
	{
		Circle_actor->GetProperty()->SetColor(colors->GetColor3d(color_chosen.toStdString()).GetData());
		qstrcpy(CircleColor, qPrintable(color_chosen));

	}
	else if (selected_shape == "Ellipse")
	{
		Ellipse_actor->GetProperty()->SetColor(colors->GetColor3d(color_chosen.toStdString()).GetData());
		qstrcpy(EllipseColor, qPrintable(color_chosen));

	}

	else if (selected_shape == "Polyline")
	{
		Polyline_actor->GetProperty()->SetColor(colors->GetColor3d(color_chosen.toStdString()).GetData());
		qstrcpy(PolylineColor, qPrintable(color_chosen));

	}

	else if (selected_shape == "Regular Polygon")
	{
		Regpolygon_actor->GetProperty()->SetColor(colors->GetColor3d(color_chosen.toStdString()).GetData());
		qstrcpy(RegPolygonColor, qPrintable(color_chosen));

	}

	else if (selected_shape == "Polygon")
	{
		Polygon_actor->GetProperty()->SetColor(colors->GetColor3d(color_chosen.toStdString()).GetData());
		qstrcpy(PolygonColor, qPrintable(color_chosen));

	}
	else if (selected_shape == "Arc")
	{
		Arc_actor->GetProperty()->SetColor(colors->GetColor3d(color_chosen.toStdString()).GetData());
		qstrcpy(ArcColor, qPrintable(color_chosen));

	}
	else if (selected_shape == "Line")
	{
		actor->GetProperty()->SetColor(colors->GetColor3d(color_chosen.toStdString()).GetData());
		qstrcpy(LineColor, qPrintable(color_chosen));

	}
	else if (selected_shape == "Sphere")
	{
		Sphere_Actor->GetProperty()->SetColor(colors->GetColor3d(color_chosen.toStdString()).GetData());
		qstrcpy(SphereColor, qPrintable(color_chosen));

	}

	else if (selected_shape == "Ellipsoid")
	{
		Ellipsoid_Actor->GetProperty()->SetColor(colors->GetColor3d(color_chosen.toStdString()).GetData());
		qstrcpy(EllipsoidColor, qPrintable(color_chosen));

	}

	else if (selected_shape == "Cube")
	{
		Cube_Actor->GetProperty()->SetColor(colors->GetColor3d(color_chosen.toStdString()).GetData());
		qstrcpy(CubeColor, qPrintable(color_chosen));

	}


}
//Update drawn shapes on window and last shape on window
void Update_Shape(const std::string& shape)
{
	Shapes_drawn.insert(shape);
	last_shape = shape;
}

void Translation(vtkLineSource* shapeSource, vtkPolyDataMapper* shapemapper, double translation_x = 0, double translation_y = 0, double translation_z = 0)
{

	//vtkSmartPointer<vtkPoints> oldPoints = shapeSource->GetPoints(); 
	vtkSmartPointer<vtkPoints> oldPoints = vtkSmartPointer<vtkPoints>::New();

	vtkSmartPointer<vtkPoints> newPoints = vtkSmartPointer<vtkPoints>::New();




	oldPoints->DeepCopy(shapeSource->GetPoints());  // All other shapes 

	newPoints->DeepCopy(oldPoints);
	for (vtkIdType i = 0; i < newPoints->GetNumberOfPoints(); i++) {
		double* currentpoint = newPoints->GetPoint(i);
		currentpoint[0] += translation_x;
		currentpoint[1] += translation_y;
		currentpoint[2] += translation_z;
		newPoints->SetPoint(i, currentpoint);
	}

	shapeSource->SetPoints(newPoints);
	shapeSource->Update();
	mapper->Update();

}

void Transformation_translation_shape(string selected_shape, double translation_x, double translation_y)
{


	if (selected_shape == "Circle")
	{
		Translation(Circle_lineSource, Circle_mapper, translation_x, translation_y);

	}
	else if (selected_shape == "Ellipse")
	{
		Translation(Ellipse_lineSource, Ellipse_mapper, translation_x, translation_y);


	}

	else if (selected_shape == "Polyline")
	{
		Translation(Polyline_lineSource, Polyline_mapper, translation_x, translation_y);

	}

	else if (selected_shape == "Regular Polygon")
	{
		Translation(Regpolygon_linesource, Regpolygon_mapper, translation_x, translation_y);


	}

	else if (selected_shape == "Polygon")
	{
		Translation(Polygon_lineSource, Polygon_mapper, translation_x, translation_y);

	}
	else if (selected_shape == "Arc")
	{
		Translation(Arc_lineSource, Arc_mapper, translation_x, translation_y);
	}
	else if (selected_shape == "Line")
	{
		Translation(lineSource, mapper, translation_x, translation_y);
	}

}

void Transformation_rotating(vtkLineSource* shapeSource, vtkPolyDataMapper* mapper, double angleOfRotation)
{
	vtkSmartPointer<vtkPoints> newPoints = vtkSmartPointer<vtkPoints>::New();

	//if (shapeSource == &(*lineSource))
	//{
	//	// If it is a line source, get the endpoints and put them in oldPoints

	//	double point1[3];
	//	double point2[3];
	//	lineSource->GetPoint1(point1); 
	//	lineSource->GetPoint2(point2);  
	//	newPoints->InsertNextPoint(point1);
	//	newPoints->InsertNextPoint(point2); 

	//}


	newPoints = shapeSource->GetPoints();



	for (vtkIdType i = 0; i < newPoints->GetNumberOfPoints(); i++)
	{
		double* point = newPoints->GetPoint(i);

		point[0] = point[0] * cos(vtkMath::RadiansFromDegrees(angleOfRotation)) - point[1] * sin(vtkMath::RadiansFromDegrees(angleOfRotation));
		point[1] = point[0] * sin(vtkMath::RadiansFromDegrees(angleOfRotation)) + point[1] * cos(vtkMath::RadiansFromDegrees(angleOfRotation));
		point[2] = 1;
		newPoints->SetPoint(i, point);
	}
	shapeSource->SetPoints(newPoints);
	shapeSource->Modified();
	mapper->Update();
}

void Transformation_Rotation_shape(string selected_shape, double Angle_rotation)
{


	if (selected_shape == "Circle")
	{
		Transformation_rotating(Circle_lineSource, Circle_mapper, Angle_rotation);
	}
	else if (selected_shape == "Ellipse")
	{
		Transformation_rotating(Ellipse_lineSource, Ellipse_mapper, Angle_rotation);


	}

	else if (selected_shape == "Polyline")
	{
		Transformation_rotating(Polyline_lineSource, Polyline_mapper, Angle_rotation);


	}

	else if (selected_shape == "Regular Polygon")
	{
		Transformation_rotating(Regpolygon_linesource, Regpolygon_mapper, Angle_rotation);


	}

	else if (selected_shape == "Polygon")
	{
		Transformation_rotating(Polygon_lineSource, Polygon_mapper, Angle_rotation);


	}
	else if (selected_shape == "Arc")
	{
		Transformation_rotating(Arc_lineSource, Arc_mapper, Angle_rotation);

	}
	else if (selected_shape == "Line")
	{
		Transformation_rotating(lineSource, mapper, Angle_rotation);

	}

}

void transformation_scaling(vtkLineSource* shapeSource, double x_axis, double y_axis, double z_axis = 1)
{
	vtkSmartPointer<vtkPoints> oldPoints = vtkSmartPointer<vtkPoints>::New();

	vtkSmartPointer<vtkPoints> newPoints = vtkSmartPointer<vtkPoints>::New();



	oldPoints->DeepCopy(shapeSource->GetPoints());

	newPoints->DeepCopy(oldPoints);
	for (vtkIdType i = 0; i < newPoints->GetNumberOfPoints(); i++)
	{
		double* point = newPoints->GetPoint(i);

		point[0] *= x_axis;
		point[1] *= y_axis;
		point[2] = 1;
		newPoints->SetPoint(i, point);
	}

	shapeSource->SetPoints(newPoints);
	shapeSource->Modified();

}

void Transformation_Scaling_shape(string selected_shape, double x_scale, double y_scale, double z_scale = 1)
{


	if (selected_shape == "Circle")
	{
		transformation_scaling(Circle_lineSource, x_scale, y_scale);
	}
	else if (selected_shape == "Ellipse")
	{
		transformation_scaling(Ellipse_lineSource, x_scale, y_scale);

	}

	else if (selected_shape == "Polyline")
	{
		transformation_scaling(Polyline_lineSource, x_scale, y_scale);
	}

	else if (selected_shape == "Regular Polygon")
	{
		transformation_scaling(Regpolygon_linesource, x_scale, y_scale);
	}

	else if (selected_shape == "Polygon")
	{
		transformation_scaling(Polygon_lineSource, x_scale, y_scale);

	}
	else if (selected_shape == "Arc")
	{
		transformation_scaling(Arc_lineSource, x_scale, y_scale);

	}
	else if (selected_shape == "Line")
	{
		transformation_scaling(lineSource, x_scale, y_scale);
	}

}

// line has only 2 points, so there is no meaning for most of the transformations on the line(2 points) !!!!
void transformation_shearing(vtkLineSource* shapeSource, double shearingConstant)
{
	vtkSmartPointer<vtkPoints>newPoints = shapeSource->GetPoints();

	for (vtkIdType i = 0; i < newPoints->GetNumberOfPoints(); i++)
	{
		double* point = newPoints->GetPoint(i);
		point[0] += shearingConstant * point[1];
		newPoints->SetPoint(i, point);

	}

	shapeSource->SetPoints(newPoints);
	shapeSource->Modified();

}


void Transformation_Shearing_shape(string selected_shape, double shear_x)
{


	if (selected_shape == "Circle")
	{
		transformation_shearing(Circle_lineSource, shear_x);
	}
	else if (selected_shape == "Ellipse")
	{
		transformation_shearing(Ellipse_lineSource, shear_x);

	}

	else if (selected_shape == "Polyline")
	{
		transformation_shearing(Polyline_lineSource, shear_x);
	}

	else if (selected_shape == "Regular Polygon")
	{
		transformation_shearing(Regpolygon_linesource, shear_x);
	}

	else if (selected_shape == "Polygon")
	{
		transformation_shearing(Polygon_lineSource, shear_x);

	}
	else if (selected_shape == "Arc")
	{
		transformation_shearing(Arc_lineSource, shear_x);

	}
	else if (selected_shape == "Line")
	{
		transformation_shearing(lineSource, shear_x);
	}

}



namespace {

	// Define interaction style
	class MouseInteractorStylePP : public vtkInteractorStyleTrackballCamera
	{
	public:

		static MouseInteractorStylePP* New();
		vtkTypeMacro(MouseInteractorStylePP, vtkInteractorStyleTrackballCamera);

		int flag = 0;

		virtual void OnLeftButtonDown() override
		{
			std::cout << "Picking pixel: " << this->Interactor->GetEventPosition()[0]
				<< " " << this->Interactor->GetEventPosition()[1] << std::endl;


			this->Interactor->GetPicker()->Pick(this->Interactor->GetEventPosition()[0],
				this->Interactor->GetEventPosition()[1],
				0, // always zero.
				this->Interactor->GetRenderWindow()
				->GetRenderers()
				->GetFirstRenderer());


			this->Interactor->GetPicker()->GetPickPosition(picked);

			std::cout << "Picked value: " << picked[0] << " " << picked[1] << " "
				<< picked[2] << std::endl;


			flag++;
			if (flag == 1) {


				for (int i = 0; i < 3; i++) {
					picked2[i] = picked[i];
				}
				if (isLine) {
					//SetFirstPoint();
					SetSecondPoint();

					//Shapes_drawn.insert("Line");
					//Update_Shape("Line");
				}
				if (isPolyline) {
					if (countIsLine == 2) {
						for (int i = 0; i <= counterPoly; i++) {
							pointsArray[i][0] = 0;
							pointsArray[i][1] = 0;
							pointsArray[i][2] = 0;
						}
						counterPoly = -1;

					}
					Draw_Polyline();
					//	Shapes_drawn.insert("Polyline");
					Update_Shape("Polyline");
					renderWindow->Render();
					flag = 0;
				}
				if (isPolygon) {
					if (countIsPolygon == 2) {
						for (int i = 0; i <= counterPolygon; i++) {
							pointsArray[i][0] = 0;
							pointsArray[i][1] = 0;
							pointsArray[i][2] = 0;
						}

						counterPolygon = -1;

					}
					Draw_Polygon();
					//Shapes_drawn.insert("Polygon");
					Update_Shape("Polygon");
					renderWindow->Render();
					flag = 0;
				}

				DrawPoint();
			}
			if (flag == 2) {
				for (int i = 0; i < 3; i++) {
					picked3[i] = picked[i];
				}
				//////////////////////////////REMOVE NEXT LINE
			//	isLine = 0;
				////////////////////////////////REMOVE PREVIOUS LINE
				if (isLine) {

					SetSecondPoint();
					Draw_Line();
					flag = 0;/*
					if (FlagLineWriteFirstTime) {*/
					//Shapes_drawn.insert("Line");
					Update_Shape("Line");
					/*	FlagLineWriteFirstTime = 0;
					}*/
				}

				if (isRegularPolygon)
				{
					Draw_Regular_Polygon();
					//Shapes_drawn.insert("Regular Polygon");
					Update_Shape("Regular Polygon");
					renderWindow->Render();
					flag = 0;
					return;

				}
				/*if (isArc) {
					Draw_Arc(arcR, arcStart, arcEnd );
					Shapes_drawn.insert("Arc");
					flag = 0;
				}*/



				std::cout << "Picked value: " << picked[0] << " " << picked[1] << " "
					<< picked[2] << std::endl;
				std::cout << "Picked2 value: " << picked2[0] << " " << picked2[1] << " "
					<< picked2[2] << std::endl;
				DrawPoint();

			}

			if (isSphere && flag == 2) {
				DrawSphere();
				Update_Shape("Sphere");
				renderWindow->Render();

				flag = 0;
				return;
			}
			if (isCube && flag == 2) {
				DrawCube();
				Update_Shape("Cube");
				renderWindow->Render();

				flag = 0;
				return;
			}

			if (isCircle && flag == 2) {


				Draw_Circle();
				//Shapes_drawn.insert("Circle");
				Update_Shape("Circle");
				renderWindow->Render();
				//renderer->RemoveAllViewProps();
				//transformation(mapper, actor, 0, 0, 0);
				//renderWindow->Render();
				flag = 0;

				return;
			}
			if (isArc && flag == 2) {


				Draw_Arc();
				//Shapes_drawn.insert("Arc");
				Update_Shape("Arc");
				renderWindow->Render();
				//renderer->RemoveAllViewProps();
				//transformation(mapper, actor, 0, 0, 0);
				//renderWindow->Render();
				flag = 0;

				return;
			}
			if (isEllipse && flag == 3) {



				Draw_Ellipse();
				//	Shapes_drawn.insert("Ellipse");
				Update_Shape("Ellipse");
				renderWindow->Render();
				flag = 0;

				return;
			}
			if (isEllipsoid && flag == 3) {



				Draw_Ellipsoid();
				//	Shapes_drawn.insert("Ellipse");
				Update_Shape("Ellipsoid");
				renderWindow->Render();
				flag = 0;

				return;
			}



			//}
			//if (clearPolyLine) {
			//	points->Delete();
			//	clearPolyLine = false;
			//	countPolyLinePoints = 0;
			//}

			vtkInteractorStyleTrackballCamera::OnLeftButtonDown();

		}



		// Forward events

	};

	vtkStandardNewMacro(MouseInteractorStylePP);
}


int main(int argc, char* argv[])
{

	QSurfaceFormat::setDefaultFormat(QVTKOpenGLNativeWidget::defaultFormat());   //line sets the default format for Qt surface to be used with VTK
	// The QSurfaceFormat is a class that defines the format for OpenGL surfaces. In this case, the QVTKOpenGLNativeWidget is used as the default format, which is a widget that provides a native OpenGL rendering context for VTK.

	QApplication app(argc, argv);  //creates QApplication object required for the Qt Application


	QMainWindow mainWindow;
	mainWindow.resize(1200, 900);
	QDockWidget controlDock;    // dockable widget attached to sides of main window
	// add the buttons to the main window
	QVBoxLayout* layout = new QVBoxLayout();//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	QWidget* centralWidget = new QWidget();
	centralWidget->setLayout(layout);
	mainWindow.setCentralWidget(centralWidget);
	//////////////////FOR LINE////////////////////
	QWidget layoutContainer;

	QPointer<QVTKOpenGLNativeWidget> vtkRenderWidget = new QVTKOpenGLNativeWidget();
	char read[100];
	QComboBox* color_comboBox = new QComboBox();

	QString selectedText;
	QSpinBox* spinBox = new QSpinBox();
	QDoubleSpinBox* Scaling_spinbox = new QDoubleSpinBox();
	QTextEdit* textBox = new QTextEdit();
	/*
	///////////////////////////////FOR POLYLINE/////////
	// Create a polydata to store everything in
	//draw normal polygon
	//QObject::connect(regPolygon, &QPushButton::clicked, [&]() {
	//	Line = false;
	//	polyL = false;
	//	regpoly = true;
	//	mainWindow.addDockWidget(Qt::LeftDockWidgetArea, &controlDock);
	//	QLabel controlDockTitle("Control Dock");
	//	controlDockTitle.setMargin(20);
	//	controlDock.setTitleBarWidget(&controlDockTitle);
	//	QPointer<QVBoxLayout> dockLayout = new QVBoxLayout();
	//	layoutContainer.setLayout(dockLayout);
	//	controlDock.setWidget(&layoutContainer);
	//	mainWindow.setCentralWidget(vtkRenderWidget);
	//	mapper->SetInputData(polyData);
	//	//vtkNew<vtkActor> actor;
	//	actor->SetMapper(mapper);
	//	actor->GetProperty()->SetColor(colors->GetColor3d("Tomato").GetData());
	//	renderer->SetBackground(namedColors->GetColor3d("black").GetData());
	//	renderWindow->SetWindowName("regular polygon");
	//	renderWindowInteractor->SetRenderWindow(renderWindow);
	//	renderer->AddActor(actor);
	//	renderWindow->SetInteractor(renderWindowInteractor);
	//	renderWindow->AddRenderer(renderer);
	//	renderWindow->SetInteractor(vtkRenderWidget->interactor());
	//	renderWindow->GetInteractor()->SetPicker(pointPicker);
	//	vtkNew<MouseInteractorStylePP> style;
	//	renderWindow->GetInteractor()->SetInteractorStyle(style);
	//	vtkRenderWidget->setRenderWindow(renderWindow);
	//	// Display the regular polygon
	//	renderWindow->Render();
	//	renderWindow->GetInteractor()->Start();
	//	mainWindow.show();
	//	});
	////draw polyline
	//QObject::connect(buttonPolyLine, &QPushButton::clicked, [&]() {
	//	Line = false;
	//	polyL = true;
	//	regpoly = false;
	//	mainWindow.addDockWidget(Qt::LeftDockWidgetArea, &controlDock);
	//	QLabel controlDockTitle("Control Dock");
	//	controlDockTitle.setMargin(20);
	//	controlDock.setTitleBarWidget(&controlDockTitle);
	//	QPointer<QVBoxLayout> dockLayout = new QVBoxLayout();
	//	layoutContainer.setLayout(dockLayout);
	//	controlDock.setWidget(&layoutContainer);
	//	mainWindow.setCentralWidget(vtkRenderWidget);
	//	polyLine->GetPointIds()->SetNumberOfIds(countPolyLinePoints);
	//	for (unsigned int i = 0; i < countPolyLinePoints; i++)
	//	{
	//		polyLine->GetPointIds()->SetId(i, i);
	//	}
	//	cells->InsertNextCell(polyLine);
	//	// Add the points to the dataset
	//	polyData->SetPoints(points);
	//	// Add the lines to the dataset
	//	polyData->SetLines(cells);
	//	// Setup actor and mapper
	//	mapper->SetInputData(polyData);
	//	//vtkNew<vtkActor> actor;
	//	actor->SetMapper(mapper);
	//	actor->GetProperty()->SetColor(colors->GetColor3d("Tomato").GetData());
	//	renderer->SetBackground(namedColors->GetColor3d("SlateGray").GetData());
	//	renderWindow->SetWindowName("PolyLine");
	//	renderWindowInteractor->SetRenderWindow(renderWindow);
	//	renderer->AddActor(actor);
	//	renderWindow->SetInteractor(renderWindowInteractor);
	//	renderWindow->AddRenderer(renderer);
	//	renderWindow->SetInteractor(vtkRenderWidget->interactor());
	//	renderWindow->GetInteractor()->SetPicker(pointPicker);
	//	vtkNew<MouseInteractorStylePP> style;
	//	renderWindow->GetInteractor()->SetInteractorStyle(style);
	//	vtkRenderWidget->setRenderWindow(renderWindow);
	//	// Display the line
	//	renderWindow->Render();
	//	renderWindow->GetInteractor()->Start();
	//	mainWindow.show();
	//	});
*/




///////////////////////////////////////////////////////////////GUI LINE////////////////////////////////////////////
	mainWindow.addDockWidget(Qt::LeftDockWidgetArea, &controlDock);

	QLabel controlDockTitle("Control Dock");
	controlDockTitle.setMargin(20);
	controlDock.setTitleBarWidget(&controlDockTitle);

	QPointer<QVBoxLayout> dockLayout = new QVBoxLayout();

	layoutContainer.setLayout(dockLayout);
	controlDock.setWidget(&layoutContainer);

	////////////////////////////////////////////////////////////////////END//////////////////////////////////////

	///////////////////////////////////////////////////////////////COMBOBOX COLOUR LINE/////////////////////////////////////////



	color_comboBox->addItem("Black");
	color_comboBox->addItem("White");
	color_comboBox->addItem("Red");
	selectedText = color_comboBox->currentText();

	dockLayout->addWidget(color_comboBox);

	/////////////////////////////////////////////////////////////////END///////////////////////////////////////////////////

	////////////////////////////////////////////////////////SPINBOX LINE WIDTH///////////////////////////////////////

	spinBox->setMinimum(0);
	spinBox->setMaximum(100);
	spinBox->setSingleStep(10);
	spinBox->setValue(1);

	dockLayout->addWidget(spinBox);
	///////////////////////////////////////////////////////////////////////////////END/////////////////////////////////
	QComboBox* shape_comboBox = new QComboBox();

	///////////////////////////////////////////////////////////////COMBOBOX COMBOBOX SHAPE SELECT/////////////////////////////////////////
	shape_comboBox->addItem("Line");
	shape_comboBox->addItem("Polyline");
	shape_comboBox->addItem("Polygon");
	shape_comboBox->addItem("Regular Polygon");
	shape_comboBox->addItem("Circle");
	shape_comboBox->addItem("Arc");
	shape_comboBox->addItem("Ellipse");
	shape_comboBox->addItem("Sphere");
	shape_comboBox->addItem("Ellipsoid");
	shape_comboBox->addItem("Cube");
	dockLayout->addWidget(shape_comboBox);

	/*QComboBox* Transformation_combobox = new QComboBox();
	Transformation_combobox->addItem("Translation");
	Transformation_combobox->addItem("Rotation");
	Transformation_combobox->addItem("Scaling");
	Transformation_combobox->addItem("Shearing");
	dockLayout->addWidget(Transformation_combobox);  */

	//QSpinBox* spinNumSides = new QSpinBox();
	///////////////////Arc Inputs///////////////
	/*QSlider* sliderR = new QSlider(Qt::Horizontal);
	sliderR->setRange(1, 100);
	sliderR->setValue(3);



	QSlider* sliderSA = new QSlider(Qt::Horizontal);
	sliderSA->setRange(0, 360);
	sliderSA->setValue(0);




	QSlider* sliderEA = new QSlider(Qt::Horizontal);
	sliderEA->setRange(0, 360);
	sliderEA->setValue(90);*/





	QObject::connect(shape_comboBox, (&QComboBox::currentIndexChanged), [&]() {

		string selectedText = shape_comboBox->currentText().toStdString();




		switch (selectedText[0]) {
		case 'C':
			if (selectedText[1] == 'i')
			{
				isEllipsoid = 0;
				isSphere = 0;
				isLine = 0;
				isEllipse = 0;
				isArc = 0;
				isRegularPolygon = 0;
				isPolygon = 0;
				isPolyline = 0;
				isCircle = 1;
				isCube = 0;
				break;
			}
			else
			{
				isEllipsoid = 0;
				isSphere = 0;
				isLine = 0;
				isEllipse = 0;
				isArc = 0;
				isRegularPolygon = 0;
				isPolygon = 0;
				isPolyline = 0;
				isCircle = 0;
				isCube = 1;
				break;
			}

		case 'L':
			isEllipsoid = 0;
			isSphere = 0;
			isLine = 1;
			isEllipse = 0;
			isArc = 0;
			isRegularPolygon = 0;
			isPolygon = 0;
			isPolyline = 0;
			isCircle = 0;
			FlagLineWriteFirstTime = 0;
			isCube = 0;

			break;
		case 'S':
			isEllipsoid = 0;
			isSphere = 1;
			isLine = 0;
			isEllipse = 0;
			isArc = 0;
			isRegularPolygon = 0;
			isPolygon = 0;
			isPolyline = 0;
			isCircle = 0;
			FlagLineWriteFirstTime = 0;
			isCube = 0;
			break;


		case 'E':


			if (selectedText[6] == 'e') {
				/*dockLayout->removeWidget(sliderR);
				dockLayout->removeWidget(sliderSA);
				dockLayout->removeWidget(sliderEA);*/

				/*if (spinNumSides->value() != NULL) {
					dockLayout->removeWidget(spinNumSides);
				}*/
				isEllipsoid = 0;
				isSphere = 0;
				isLine = 0;
				isEllipse = 1;
				isArc = 0;
				isRegularPolygon = 0;
				isPolygon = 0;
				isPolyline = 0;
				isCircle = 0;
				isCube = 0;
				break;
			}

			else {

				countIsPolygon++;
				isLine = 0;
				isEllipse = 0;
				isArc = 0;
				isRegularPolygon = 0;
				isPolygon = 0;
				isPolyline = 0;
				isCircle = 0;
				isSphere = 0;
				isEllipsoid = 1;
				isCube = 0;
				break;
			}

		case 'R':

			/*dockLayout->removeWidget(sliderR);
			dockLayout->removeWidget(sliderSA);
			dockLayout->removeWidget(sliderEA);*/
			isEllipsoid = 0;
			isSphere = 0;
			isLine = 0;
			isEllipse = 0;
			isArc = 0;
			isRegularPolygon = 1;
			isPolygon = 0;
			isPolyline = 0;
			isCircle = 0;
			isCube = 0;


			/*	spinNumSides->setMinimum(0);
				spinNumSides->setMaximum(100);
				spinNumSides->setSingleStep(1);
				spinNumSides->setValue(NumSides);

				dockLayout->addWidget(spinNumSides);*/

			break;
		case 'A':
			/*if (spinNumSides->value() != NULL) {
				dockLayout->removeWidget(spinNumSides);
			}*/
			isEllipsoid = 0;
			isSphere = 0;
			isLine = 0;
			isEllipse = 0;
			isArc = 1;
			isRegularPolygon = 0;
			isPolygon = 0;
			isPolyline = 0;
			isCircle = 0;
			isCube = 0;


			/*dockLayout->addWidget(sliderR);
			dockLayout->addWidget(sliderSA);
			dockLayout->addWidget(sliderEA);*/



			/*	QObject::connect(sliderR, &QSlider::valueChanged, [&]() {
					arcR = sliderR->value();
					Draw_Arc(arcR, arcStart, arcEnd);
					});

				QObject::connect(sliderSA, &QSlider::valueChanged, [&]() {
					arcStart = sliderSA->value();
					Draw_Arc(arcR, arcStart, arcEnd);
					});

				QObject::connect(sliderEA, &QSlider::valueChanged, [&]() {
					arcEnd = sliderEA->value();
					Draw_Arc(arcR, arcStart, arcEnd);
					});*/

					// Show the widget
					//layoutContainer.show();
			break;
		case 'P':

			if (selectedText[4] == 'l') {
				countIsLine++;
				isLine = 0;
				isEllipse = 0;
				isArc = 0;
				isRegularPolygon = 0;
				isPolygon = 0;
				isPolyline = 1;
				isCircle = 0;
				isSphere = 0;
				isEllipsoid = 0;
				isCube = 0;
				break;
			}
			else {
				/*	dockLayout->removeWidget(sliderR);
					dockLayout->removeWidget(sliderSA);
					dockLayout->removeWidget(sliderEA);*/
					/*	if (spinNumSides->value() != NULL) {
							dockLayout->removeWidget(spinNumSides);
						}*/
				countIsPolygon++;
				isLine = 0;
				isEllipse = 0;
				isArc = 0;
				isRegularPolygon = 0;
				isPolygon = 1;
				isPolyline = 0;
				isCircle = 0;
				isSphere = 0;
				isEllipsoid = 0;
				isCube = 0;
				break;
			}
		}

		// update selectedText with the current selected item

		if (isArc)
		{
			arcStart = QInputDialog::getDouble(nullptr, "Input Start Angle", "Start Angle");
			arcEnd = QInputDialog::getDouble(nullptr, "Input End Angle", "End Angle");

		}

		if (isRegularPolygon)
		{
			NumSides = QInputDialog::getDouble(nullptr, "Input Number of sides", "Regular Polygon");

		}



		renderWindow->Render();
		});

	///////////////////////////////////////////////////////////////////////////////END/////////////////////////////////

	///////////////////////////////////////////////////////////////////READ WRITE BUTTONS////////////////////////////////////
	QPushButton* pushButton = new QPushButton("Read File");
	QPushButton* pushButton2 = new QPushButton("Write File");
	dockLayout->addWidget(pushButton);
	dockLayout->addWidget(pushButton2);

	/////////////////Scaling_spinbox///////////////////
	Scaling_spinbox->setMinimum(-5.0);
	Scaling_spinbox->setMaximum(5.0);
	Scaling_spinbox->setSingleStep(1.0);
	Scaling_spinbox->setValue(1.0);

	dockLayout->addWidget(Scaling_spinbox);

	////////////////////////End///////////////////////


	QPushButton* Delete_button = new QPushButton("Delete Shape");
	dockLayout->addWidget(Delete_button);

	//______________Transformation Buttons__________//
	QComboBox* Transformation_combobox = new QComboBox();
	Transformation_combobox->addItem("Select Mode");
	Transformation_combobox->addItem("Rotation");
	Transformation_combobox->addItem("Translation");
	Transformation_combobox->addItem("Shearing");
	Transformation_combobox->addItem("Scaling");

	dockLayout->addWidget(Transformation_combobox);
	//______________________________________________//

	mainWindow.setCentralWidget(vtkRenderWidget);


	QObject::connect(Transformation_combobox, QOverload<int>::of(&QComboBox::activated), [&]() {

		QString selectedTransformation = Transformation_combobox->currentText();

		if (selectedTransformation == "Translation")
		{
			Translation_x = QInputDialog::getDouble(nullptr, "Translation_x", "Translation in x ");
			Translation_y = QInputDialog::getDouble(nullptr, "Translation_y", "Translation in y");
		}
		else if (selectedTransformation == "Rotation")
		{
			Rotation_angle = QInputDialog::getDouble(nullptr, "Rotation ", "Rotation angle");

		}

		else if (selectedTransformation == "Shearing")
		{
			Shearing_x = QInputDialog::getDouble(nullptr, "Shearing_x ", "Shearing in x");

		}

		else if (selectedTransformation == "Scaling")
		{
			Scale_x = QInputDialog::getDouble(nullptr, "Scale_x ", "Scaling x");
			Scale_y = QInputDialog::getDouble(nullptr, "Scale_y ", "Scaling in y");
		}







		QMessageBox Translation_Box;
		Translation_Box.setText("                        Choose an option:");
		Translation_Box.setStandardButtons(QMessageBox::Ok | QMessageBox::Cancel);

		Translation_Box.addButton(QMessageBox::tr("All shapes"), QMessageBox::ActionRole);
		Translation_Box.addButton(QMessageBox::tr("Last Shape"), QMessageBox::ActionRole);



		QComboBox* Shapes_combobox = new QComboBox(&Translation_Box);

		for (const auto& shape : Shapes_drawn)
		{
			Shapes_combobox->addItem(QString::fromStdString(shape));

		}

		Translation_Box.exec();



		int result = Translation_Box.result();

		//Update last shape drawn



		if (result == 0)
		{
			//All shapes chosen
			for (const auto& shape : Shapes_drawn)   //loop on all the drawn shapes 
			{
				string shape_str = shape;

				if (selectedTransformation == "Translation") {
					Transformation_translation_shape(shape_str, Translation_x, Translation_y);
				}

				else  if (selectedTransformation == "Rotation")
				{
					Transformation_Rotation_shape(shape_str, Rotation_angle);
				}

				else if (selectedTransformation == "Scaling")
				{
					Transformation_Scaling_shape(shape_str, Scale_x, Scale_y);
				}
				else if (selectedTransformation == "Shearing")
				{
					Transformation_Shearing_shape(shape_str, Shearing_x);

				}



			}

		}

		else if (result == 1)
		{
			//Last shape chosen
			if (!last_shape.empty())
			{
				if (selectedTransformation == "Translation") {
					Transformation_translation_shape(last_shape, Translation_x, Translation_y);

				}

				else  if (selectedTransformation == "Rotation")
				{
					Transformation_Rotation_shape(last_shape, Rotation_angle);
				}

				else if (selectedTransformation == "Scaling")
				{
					Transformation_Scaling_shape(last_shape, Scale_x, Scale_y);
				}

				else if (selectedTransformation == "Shearing")
				{
					Transformation_Shearing_shape(last_shape, Shearing_x);

				}

			}

		}

		else
		{
			//Shape from Dropdown list selected
			std::string selectedShape = Shapes_combobox->currentText().toStdString();

			if (selectedTransformation == "Translation") {
				Transformation_translation_shape(selectedShape, Translation_x, Translation_y);
			}
			else  if (selectedTransformation == "Rotation")
			{
				Transformation_Rotation_shape(selectedShape, Rotation_angle);
			}

			else if (selectedTransformation == "Scaling")
			{
				Transformation_Scaling_shape(selectedShape, Scale_x, Scale_y);
			}
			else if (selectedTransformation == "Shearing")
			{
				Transformation_Shearing_shape(selectedShape, Shearing_x);

			}

		}
		renderWindow->Render();




		});





	QObject::connect(Delete_button, &QPushButton::released, [&]() {

		QMessageBox Delete_box;
		Delete_box.setText("                        Choose an option:");
		Delete_box.setStandardButtons(QMessageBox::Ok | QMessageBox::Cancel);

		Delete_box.addButton(QMessageBox::tr("All shapes"), QMessageBox::ActionRole);
		Delete_box.addButton(QMessageBox::tr("Last Shape"), QMessageBox::ActionRole);



		QComboBox* Shapes_combobox = new QComboBox(&Delete_box);

		for (const auto& shape : Shapes_drawn)
		{
			Shapes_combobox->addItem(QString::fromStdString(shape));

		}

		Delete_box.exec();


		int result = Delete_box.result();



		if (result == 0)
		{


			//All shapes chosen
			for (const auto& shape : Shapes_drawn)   //loop on all the drawn shapes 
			{
				string shape_str = shape;
				//last_shape = "";

				Delete_Shape(shape_str);

			}

			Shapes_drawn.clear();
			last_shape = "";

		}

		else if (result == 1)
		{
			//Last shape chosen
			if (!last_shape.empty())
			{
				Delete_Shape(last_shape);
				Shapes_drawn.erase(last_shape);


				if (!Shapes_drawn.empty())
				{
					auto iterator = std::prev(Shapes_drawn.end());
					last_shape = *iterator;
				}

			}

		}

		else
		{
			//Shape from Dropdown list selected
			std::string selectedShape = Shapes_combobox->currentText().toStdString();

			Delete_Shape(selectedShape);

			Shapes_drawn.erase(selectedShape);

			if (!Shapes_drawn.empty())
			{
				auto iterator = std::prev(Shapes_drawn.end());
				last_shape = *iterator;
			}

		}

		renderWindow->Render();

		});



	///////////////////////LINE/////////////////////////////


	//Draw_Circle(3);
//	Draw_Arc();
	//Draw_Ellipse();

	mapper->SetInputConnection(lineSource->GetOutputPort());
	mapper->Update();
	actor->GetProperty()->SetColor(colors->GetColor3d(selectedText.toStdString()).GetData());
	/*LineColor = selectedText.toStdString().c_str();
	actor->GetProperty()->SetLineWidth(spinBox->value());*/
	LineWidth = spinBox->value();
	actor->SetMapper(mapper);
	renderer->AddActor(actor);
	renderWindow->AddRenderer(renderer);

	//renderWindow->SetInteractor(renderWindowInteractor);


	/////////////////////////////////////////////////////READ PUSH BUTTON//////////////////////////////////////
	LineColor[0] = 'B';
	LineColor[1] = 'l';
	LineColor[2] = 'a';
	LineColor[3] = 'c';
	LineColor[4] = 'k';
	QObject::connect(pushButton, &QPushButton::released, [&]() {

		QString text2 = QInputDialog::getText(nullptr, "Input File Name to be Read", "File Name");
		qDebug() << "Input: " << text2;


		strcpy(read, text2.toStdString().c_str());


		ReadFile(read);
		spinBox->setValue(LineWidth);
		//color_comboBox->setCurrentText(LineColor);
		//vtkSmartPointer<vtkLineSource> lineSource = vtkSmartPointer<vtkLineSource>::New();
		actor->GetProperty()->SetLineWidth(LineWidth);
		//actor->GetProperty()->SetColor(colors->GetColor3d(LineColor).GetData());
		//SetFirstPoint();
		//SetSecondPoint();
		//lineSource->Update();
		//cout << picked[1] << "                         " << picked2[1];
		//mapper->Update();

		DrawPoint();





		});

	//////////////////////////////////////////////////////////////// END///////////////////////////////
	//char test[100] = { 't','e','s','t' };
//	ReadFile(test);

	//SetFirstPoint();
	//SetSecondPoint();



	////////////////////////////////////////////////////////////////WRITE PUSH BUTTON////////////////////////////////
	QObject::connect(pushButton2, &QPushButton::released, [&]() {
		QString text = QInputDialog::getText(nullptr, "Input File Name to be written", "File Name");
		qDebug() << "Input: " << text;
		string write;
		write = text.toStdString();
		write = write + ".txt";
		WriteFile(write);
		});

	//////////////////////////////////////////////////////////////////////END/////////////////////////////////////////////

	////////////////////////////////////////////SET READ VALUES (COLOUR AND WIDTH) IN COMBOBOX AND SPINBOX///////////////
	actor->GetProperty()->SetLineWidth(spinBox->value());
	cout << "color  " << selectedText.toStdString();
	cout << "Linewidth  " << spinBox->value();
	actor->GetProperty()->SetColor(colors->GetColor3d(selectedText.toStdString()).GetData());
	//////////////////////////////////////////////////////////END///////////////////////////////////////////////////////////



	renderer->SetBackground(namedColors->GetColor3d("SlateGray").GetData());
	///////////////////////////////////////////////////////////COMBOBOX WIDGET APPLIED/////////////////////////////////

	QObject::connect(color_comboBox, QOverload<int>::of(&QComboBox::activated), [&]() {
		//Another function change color

		selectedText = color_comboBox->currentText();
		QMessageBox Color_changebox;
		Color_changebox.setText("                        Choose an option:");
		Color_changebox.setStandardButtons(QMessageBox::Ok | QMessageBox::Cancel);

		Color_changebox.addButton(QMessageBox::tr("All shapes"), QMessageBox::ActionRole);
		Color_changebox.addButton(QMessageBox::tr("Last Shape"), QMessageBox::ActionRole);



		QComboBox* Shapes_combobox = new QComboBox(&Color_changebox);

		for (const auto& shape : Shapes_drawn)
		{
			Shapes_combobox->addItem(QString::fromStdString(shape));

		}

		Color_changebox.exec();



		int result = Color_changebox.result();

		//Update last shape drawn



		if (result == 0)
		{
			//All shapes chosen
			for (const auto& shape : Shapes_drawn)   //loop on all the drawn shapes 
			{
				string shape_str = shape;

				change_color(selectedText, shape_str);

			}

		}

		else if (result == 1)
		{
			//Last shape chosen
			if (!last_shape.empty())
			{
				//last_shape = *Shapes_drawn.rbegin();   // get the last shape drawn 
				change_color(selectedText, last_shape);
			}

		}

		else
		{
			//Shape from Dropdown list selected
			std::string selectedShape = Shapes_combobox->currentText().toStdString();
			change_color(selectedText, selectedShape);


		}
		/*	if (!Shapes_drawn.empty())
			{
				last_shape = *Shapes_drawn.rbegin();

			}*/

		renderWindow->Render();
		});
	///////////////////////////////////////////////////////////END//////////////////////////////////////////////
	// 
	//////////////////////////////////////////////////////////////////////SPINBOX WIDGET APPLIED///////////////////////////////////
	QObject::connect(spinBox, static_cast<void(QSpinBox::*)(int)>(&QSpinBox::valueChanged), [&]() {

		int shape_width = spinBox->value();
		QMessageBox Width_Box;
		Width_Box.setText("                        Choose an option:");
		Width_Box.setStandardButtons(QMessageBox::Ok | QMessageBox::Cancel);

		Width_Box.addButton(QMessageBox::tr("All shapes"), QMessageBox::ActionRole);
		Width_Box.addButton(QMessageBox::tr("Last Shape"), QMessageBox::ActionRole);



		QComboBox* Shapes_combobox = new QComboBox(&Width_Box);

		for (const auto& shape : Shapes_drawn)
		{
			Shapes_combobox->addItem(QString::fromStdString(shape));

		}

		Width_Box.exec();



		int result = Width_Box.result();

		//Update last shape drawn



		if (result == 0)
		{
			//All shapes chosen
			for (const auto& shape : Shapes_drawn)   //loop on all the drawn shapes 
			{
				string shapes_str = shape;
				change_width_shape(shape_width, shapes_str);


			}

		}

		else if (result == 1)
		{
			//Last shape chosen
			if (!last_shape.empty())
			{
				change_width_shape(shape_width, last_shape);

			}

		}

		else
		{
			//Shape from Dropdown list selected
			std::string selectedShape = Shapes_combobox->currentText().toStdString();
			change_width_shape(shape_width, selectedShape);


		}


		renderWindow->Render();
		});




	renderWindow->SetInteractor(renderWindowInteractor);


	renderWindow->AddRenderer(renderer);
	renderWindow->SetInteractor(vtkRenderWidget->interactor());

	renderWindow->GetInteractor()->SetPicker(pointPicker);
	vtkNew<MouseInteractorStylePP> style;
	renderWindow->GetInteractor()->SetInteractorStyle(style);



	vtkRenderWidget->setRenderWindow(renderWindow);


	// Display the line
	renderWindow->Render();


	renderWindow->GetInteractor()->Start();


	mainWindow.show();



	mainWindow.show();

	return app.exec();


}