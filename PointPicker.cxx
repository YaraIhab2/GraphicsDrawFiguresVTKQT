#include <vtkActor.h>
#include <vtkInteractorStyleTrackballCamera.h>
#include <vtkNamedColors.h>
#include <vtkNew.h>
#include <vtkObjectFactory.h>
#include <vtkPointPicker.h>
#include <vtkPolyDataMapper.h>
#include <vtkRegularPolygonSource.h>
#include <vtkProperty.h>
#include <vtkRenderWindow.h>
#include <vtkRenderWindowInteractor.h>
#include <vtkRenderer.h>
#include <vtkRendererCollection.h>
#include <vtkSphereSource.h>
#include <vtkSmartPointer.h>
#include <vtkRenderWindow.h>
#include <vtkRenderer.h>
#include <vtkRenderWindowInteractor.h>
#include <vtkInteractorStyleTrackballCamera.h>
#include <vtkPoints.h>
#include <vtkCellArray.h>
#include <vtkPolyData.h>
#include <vtkLineSource.h>
#include <vtkPicker.h>
#include <vtkTextActor.h>
#include <vtkTextWidget.h>
#include <vtkTextProperty.h>
#include <vtkTextRepresentation.h>
#include <vtkNamedColors.h>
#include <vtkActor.h>
#include <QWidget>
#include <vtkCommand.h>
#include <vtkCoordinate.h>
#include <vtkNamedColors.h>
#include <vtkNew.h>
#include <vtkPolyDataMapper.h>
#include <vtkProperty.h>
#include <vtkRenderWindow.h>
#include <vtkRenderWindowInteractor.h>
#include <vtkRenderer.h>
#include <vtkSphereSource.h>
#include <vtkTextActor.h>
#include <vtkTextProperty.h>
#include <vtkTextRepresentation.h>
#include <vtkTextWidget.h>
#include <string>
#include <sstream>
#include <iostream>
#include <fstream>
#include< stdio.h >
#include <vtkTexturedButtonRepresentation2D.h>
#include <vtkPNGReader.h>
#include <vtkButtonWidget.h>
#include <vtkImageData.h>
#include <vtkTexture.h>
#include <vtkImageViewer2.h>
#include <vtkNamedColors.h>
#include <vtkImageCanvasSource2D.h>
#include <vtkImageData.h>
#include <vtkImageDataGeometryFilter.h>
#include <QVTKOpenGLNativeWidget.h>
#include <vtkActor.h>
#include <vtkDataSetMapper.h>
#include <vtkDoubleArray.h>
#include <vtkGenericOpenGLRenderWindow.h>
#include <vtkPointData.h>
#include <vtkProperty.h>
#include <vtkRenderer.h>
#include <vtkSphereSource.h>
#include <vtkTubeFilter.h>
#include <QApplication>
#include <QDockWidget>
#include <QGridLayout>
#include <QLabel>
#include <QMainWindow>
#include <QPointer>
#include <QPushButton>
#include <QVBoxLayout>
#include <QObject>
#include <vtkTransform.h>
#include <vtkTransformPolyDataFilter.h>
#include <cmath>
#include <cstdlib>
#include <random>
#include <QWidget>
#include <vtkSmartPointer.h>
#include <vtkRenderWindow.h>

#include <QtCore/QObject>
#include <QtCore/QDebug>
#include <QtWidgets/QApplication>
#include <QtWidgets/QPushButton>
#include <QLineEdit>
#include <QInputDialog>
#include <QComboBox>
#include <QSpinBox>
#include <vtkActor.h>
#include <vtkInteractorStyleTrackballCamera.h>
#include <vtkNamedColors.h>
#include <vtkNew.h>
#include <vtkObjectFactory.h>
#include <vtkPointPicker.h>
#include <vtkPolyDataMapper.h>
#include <vtkProperty.h>
#include <vtkRenderWindow.h>
#include <vtkRenderWindowInteractor.h>
#include <vtkRenderer.h>
#include <vtkRendererCollection.h>
#include <vtkSphereSource.h>
#include <vtkSmartPointer.h>
#include <vtkRenderWindow.h>
#include <vtkRenderer.h>
#include <vtkRenderWindowInteractor.h>
#include <vtkInteractorStyleTrackballCamera.h>
#include <vtkPolyDataMapper.h>
#include <vtkActor.h>
#include <vtkProperty.h>
#include <vtkPoints.h>
#include <vtkCellArray.h>
#include <vtkPolyData.h>
#include <vtkLineSource.h>
#include <vtkPicker.h>
#include <vtkTextActor.h>
#include <vtkTextWidget.h>
#include <vtkTextProperty.h>
#include <vtkTextRepresentation.h>
#include <vtkNamedColors.h>
#include <vtkActor.h>
#include <QWidget>
#include <vtkCommand.h>
#include <vtkCoordinate.h>
#include <vtkNamedColors.h>
#include <vtkNew.h>
#include <vtkPolyDataMapper.h>
#include <vtkProperty.h>
#include <vtkRenderWindow.h>
#include <vtkRenderWindowInteractor.h>
#include <vtkRenderer.h>
#include <vtkSphereSource.h>
#include <vtkTextActor.h>
#include <vtkTextProperty.h>
#include <vtkTextRepresentation.h>
#include <vtkTextWidget.h>
#include <string>
#include <sstream>
#include <iostream>
#include <fstream>
#include< stdio.h >
#include <vtkTexturedButtonRepresentation2D.h>
#include <vtkPNGReader.h>
#include <vtkButtonWidget.h>
#include <vtkImageData.h>
#include <vtkTexture.h>
#include <vtkImageViewer2.h>
#include <vtkNamedColors.h>
#include <vtkImageCanvasSource2D.h>
#include <vtkImageData.h>
#include <vtkImageDataGeometryFilter.h>
#include <QVTKOpenGLNativeWidget.h>
#include <vtkActor.h>
#include <vtkDataSetMapper.h>
#include <vtkDoubleArray.h>
#include <vtkGenericOpenGLRenderWindow.h>
#include <vtkPointData.h>
#include <vtkProperty.h>
#include <vtkRenderer.h>
#include <vtkSphereSource.h>
#include <vtkTubeFilter.h>
#include <QApplication>
#include <QDockWidget>
#include <QGridLayout>
#include <QLabel>
#include <QMainWindow>
#include <QPointer>
#include <QPushButton>
#include <QVBoxLayout>
#include <QObject>
#include <vtkHexahedron.h>
#include <QTextEdit>

#include <vtkActor.h>
#include <vtkCellArray.h>
#include <vtkCellData.h>
#include <vtkDoubleArray.h>
#include <vtkNamedColors.h>
#include <vtkNew.h>
#include <vtkRegularPolygonSource.h>
#include <vtkPoints.h>
#include <vtkPolyData.h>
#include <vtkPolyDataMapper.h>
#include <vtkPolyLine.h>
#include <vtkProperty.h>
#include <vtkRenderWindow.h>
#include <vtkRenderWindowInteractor.h>
#include <vtkRenderer.h>

#include <cmath>
#include <cstdlib>
#include <random>
#include <QWidget>
#include <vtkSmartPointer.h>
#include <vtkRenderWindow.h>

#include <QtCore/QObject>
#include <QtCore/QDebug>
#include <QtWidgets/QApplication>
#include <QtWidgets/QPushButton>
#include <QLineEdit>
#include <QInputDialog>
#include <QComboBox>
#include <QSpinBox>
#include<QMessageBox>
#include <vtkActor.h>
#include <vtkCamera.h>
#include <vtkCellArray.h>
#include <vtkDataSetMapper.h>
#include <vtkHexahedron.h>
#include <vtkNamedColors.h>
#include <vtkNew.h>
#include <vtkPoints.h>
#include <vtkProperty.h>
#include <vtkRenderWindow.h>
#include <vtkRenderWindowInteractor.h>
#include <vtkRenderer.h>
#include <vtkUnstructuredGrid.h>
#include <cmath>
#include <set>
using namespace std;
//__________Initializing some global variables___________________//
bool widget = 0;
set<string>Shapes_drawn;   //Store drawn shapes
double picked[3];
double picked2[3] = {};
double picked3[3] = {};
double x = 0, y = 0, z = 0, z2 = 0, x2 = 0, y2 = 0;
int LineWidth = 3;
char LineColor[100];
int countIsPolygon = 0;
int startAngle = 0;
int endAngle = 0;
//LineColor[0]='B';
//_______________________________________________________________//

vtkNew<vtkPointPicker> pointPicker;

vtkNew<vtkNamedColors> colors;
vtkNew<vtkNamedColors> namedColors;

//_____________________Line source,actor,mapper for each shape________________________________//

//Line
vtkSmartPointer<vtkLineSource> lineSource = vtkSmartPointer<vtkLineSource>::New();
vtkSmartPointer<vtkPolyDataMapper> mapper = vtkSmartPointer<vtkPolyDataMapper>::New();
vtkSmartPointer<vtkActor> actor = vtkSmartPointer<vtkActor>::New();
vtkSmartPointer<vtkPoints> points = vtkSmartPointer<vtkPoints>::New();

//Circle
vtkSmartPointer<vtkLineSource> Circle_lineSource = vtkSmartPointer<vtkLineSource>::New();
vtkSmartPointer<vtkPolyDataMapper> Circle_mapper = vtkSmartPointer<vtkPolyDataMapper>::New();
vtkSmartPointer<vtkActor> Circle_actor = vtkSmartPointer<vtkActor>::New();

//Ellipse
vtkSmartPointer<vtkLineSource> Ellipse_lineSource = vtkSmartPointer<vtkLineSource>::New();
vtkSmartPointer<vtkPolyDataMapper> Ellipse_mapper = vtkSmartPointer<vtkPolyDataMapper>::New();
vtkSmartPointer<vtkActor> Ellipse_actor = vtkSmartPointer<vtkActor>::New();

//Regpolygon
vtkSmartPointer<vtkLineSource> Regpolygon_linesource = vtkSmartPointer<vtkLineSource>::New();
vtkSmartPointer<vtkPolyDataMapper> Regpolygon_mapper = vtkSmartPointer<vtkPolyDataMapper>::New();
vtkSmartPointer<vtkActor> Regpolygon_actor = vtkSmartPointer<vtkActor>::New();

//Polyline
vtkSmartPointer<vtkLineSource> Polyline_lineSource = vtkSmartPointer<vtkLineSource>::New();
vtkSmartPointer<vtkPolyDataMapper> Polyline_mapper = vtkSmartPointer<vtkPolyDataMapper>::New();
vtkSmartPointer<vtkActor> Polyline_actor = vtkSmartPointer<vtkActor>::New();

//Polygon
vtkSmartPointer<vtkLineSource> Polygon_lineSource = vtkSmartPointer<vtkLineSource>::New();
vtkSmartPointer<vtkPolyDataMapper> Polygon_mapper = vtkSmartPointer<vtkPolyDataMapper>::New();
vtkSmartPointer<vtkActor> Polygon_actor = vtkSmartPointer<vtkActor>::New();

//Arc
vtkSmartPointer<vtkLineSource> Arc_lineSource = vtkSmartPointer<vtkLineSource>::New();
vtkSmartPointer<vtkPolyDataMapper> Arc_mapper = vtkSmartPointer<vtkPolyDataMapper>::New();
vtkSmartPointer<vtkActor> Arc_actor = vtkSmartPointer<vtkActor>::New();


//Star
vtkSmartPointer<vtkLineSource> Star_lineSource = vtkSmartPointer<vtkLineSource>::New();
vtkSmartPointer<vtkPolyDataMapper> Star_mapper = vtkSmartPointer<vtkPolyDataMapper>::New();
vtkSmartPointer<vtkActor> Star_actor = vtkSmartPointer<vtkActor>::New();



//Rossette
vtkSmartPointer<vtkLineSource> Rossette_lineSource = vtkSmartPointer<vtkLineSource>::New();
vtkSmartPointer<vtkPolyDataMapper> Rossette_mapper = vtkSmartPointer<vtkPolyDataMapper>::New();
vtkSmartPointer<vtkActor> Rossette_actor = vtkSmartPointer<vtkActor>::New();





//_____________________________________________________________________________________________//


vtkSmartPointer<vtkRenderer> renderer = vtkSmartPointer<vtkRenderer>::New();
vtkSmartPointer<vtkGenericOpenGLRenderWindow> renderWindow = vtkSmartPointer<vtkGenericOpenGLRenderWindow>::New();
vtkNew<vtkRenderWindowInteractor> renderWindowInteractor;
// vtkSmartPointer<vtkRenderWindow> renderWindow = vtkSmartPointer<vtkRenderWindow>::New();
//For coordinates text box
std::stringstream ss; 
vtkSmartPointer <vtkTextWidget> textWidget = vtkSmartPointer<vtkTextWidget>::New();
vtkSmartPointer<vtkTextActor> textActor = vtkSmartPointer<vtkTextActor>::New();
string pt;
string pt2;
//
bool polyL = false;
bool Line = true;
bool regpoly = false;
bool clearPolyLine = false;
bool circle = false;
int NumSides = 5;
float Scale_factor = 1;
int countPolyLinePoints = 0;

//vtkSmartPointer<vtkPoints> points = vtkSmartPointer<vtkPoints>::New();

//vtkSmartPointer<vtkPolyData> polyData = vtkSmartPointer <vtkPolyData>::New();
//vtkSmartPointer<vtkPolyLine> polyLine = vtkSmartPointer<vtkPolyLine>::New();
//vtkSmartPointer<vtkCellArray> cells = vtkSmartPointer<vtkCellArray>::New();
int countIsLine = 0;
bool isCircle = 0;
bool isEllipse = 0;
bool isArc = 0;
bool isRegularPolygon = 0;
bool isPolygon = 0;
bool isPolyline = 0;
bool isLine = 1;
double pointsArray[100][3];
/////////////////////////////////////////Functions used by classes////////////////////////
//set the first point of the line
void SetFirstPoint() {

	lineSource->SetPoint1(picked2[0], picked2[1], picked2[2]);
	return;
}

//set the second point of the line
void SetSecondPoint() {

	lineSource->SetPoint2(picked[0], picked[1], picked[2]);
	//lineSource->Modified();
	lineSource->Update();
}


void InsertPolyPoint() {
	points->InsertNextPoint(picked[0], picked[1], picked[2]);
	std::cout << "Picked value of polyline: " << picked[0] << " " << picked[1] << " "
		<< picked[2] << std::endl;

}

void Set_line_shape(vtkLineSource* Shape_line, vtkPoints* Shape_points, vtkPolyDataMapper* Shape_mapper, vtkActor* Shape_actor, vtkRenderer* renderer)
{
	Shape_line->SetPoints(Shape_points);
	Shape_mapper->SetInputConnection(Shape_line->GetOutputPort());
	Shape_mapper->Update();
	Shape_actor->SetMapper(Shape_mapper);
	Shape_actor->GetProperty()->SetColor(1.0, 0.0, 0.0);   //Have to change this default color
	Shape_actor->GetProperty()->SetLineWidth(3.0);

	renderer->AddActor(Shape_actor);
}
int counterPoly = -1;
int counterPolygon = -1;
void Draw_Polyline() {

	vtkSmartPointer<vtkPoints> points = vtkSmartPointer<vtkPoints>::New();
	counterPoly++;
	countIsLine = 1;
	//points->InsertNextPoint(picked[0], picked[1], 0);
	//vtkSmartPointer<vtkPoints> point1 = vtkSmartPointer<vtkPoints>::New();
	////point1=points->GetPoint(0);

	//vtkSmartPointer<vtkPoints> newPoints = vtkSmartPointer<vtkPoints>::New();
	//newPoints->DeepCopy(points);

	pointsArray[counterPoly][0] = picked[0];
	pointsArray[counterPoly][1] = picked[1];
	pointsArray[counterPoly][2] = 0;
	//pointsArray[i].Take(point1);

	for (int j = 0; j <= counterPoly; j++) {
		points->InsertNextPoint(pointsArray[j][0], pointsArray[j][1], 0);

	}
	//lineSource->SetPoints(points);
	//mapper->SetInputConnection(lineSource->GetOutputPort());
	//mapper->Update();
	//actor->SetMapper(mapper);
	////actor->GetProperty()->SetColor(LineColor);
	//renderer->AddActor(actor);
	//renderWindow->AddRenderer(renderer);
	Set_line_shape(Polyline_lineSource, points, Polyline_mapper, Polyline_actor, renderer);
	renderWindow->AddRenderer(renderer);
	renderWindow->Render();
	/*renderWindowInteractor->SetRenderWindow(renderWindow);*/


}
void Draw_Polygon() {

	vtkSmartPointer<vtkPoints> points = vtkSmartPointer<vtkPoints>::New();
	counterPolygon++;
	countIsPolygon = 1;
	//points->InsertNextPoint(picked[0], picked[1], 0);
	//vtkSmartPointer<vtkPoints> point1 = vtkSmartPointer<vtkPoints>::New();
	////point1=points->GetPoint(0);

	//vtkSmartPointer<vtkPoints> newPoints = vtkSmartPointer<vtkPoints>::New();
	//newPoints->DeepCopy(points);

	pointsArray[counterPolygon][0] = picked[0];
	pointsArray[counterPolygon][1] = picked[1];
	pointsArray[counterPolygon][2] = 0;
	//pointsArray[i].Take(point1);

	for (int j = 0; j <= counterPolygon; j++) {
		/*if ((counterPolygon != 0) && j==counterPolygon-1) {
			pointsArray[counterPolygon][0] = 0;
			pointsArray[counterPolygon][1] = 0;
			pointsArray[counterPolygon][2] = 0;
		}*/
		points->InsertNextPoint(pointsArray[j][0], pointsArray[j][1], 0);
		if (j == counterPolygon) {
			points->InsertNextPoint(pointsArray[0][0], pointsArray[0][1], 0);
		}
	}

	Set_line_shape(Polygon_lineSource, points, Polygon_mapper, Polygon_actor, renderer);

	//lineSource->SetPoints(points);
	//mapper->SetInputConnection(lineSource->GetOutputPort());
	//mapper->Update();
	//actor->SetMapper(mapper);


	//renderer->AddActor(actor);

	renderWindow->AddRenderer(renderer);
	renderWindow->Render();

}


void transformation(vtkPolyDataMapper* mapper, vtkActor* actor, double x_axis, double y_axis, double z_axis) {
	//vtkNew<vtkPolyDataMapper> originalMapper;
	mapper->SetInputConnection(lineSource->GetOutputPort());

	//vtkNew<vtkActor> originalActor;
	actor->SetMapper(mapper);
	//originalActor->GetProperty()->SetColor(colors->GetColor3d("Blue").GetData());

	// Set up the transform filter

	vtkNew<vtkTransform> translation;
	//translation->Translate(x_axis, y_axis, z_axis);
	translation->Translate(2.0, 2.0, 0.0);

	vtkNew<vtkTransformPolyDataFilter> transformFilter;
	transformFilter->SetInputConnection(lineSource->GetOutputPort());
	transformFilter->SetTransform(translation);
	transformFilter->Update();

	// Set up the actor to display the transformed polydata

	vtkNew<vtkPolyDataMapper> transformedMapper;
	transformedMapper->SetInputConnection(transformFilter->GetOutputPort());

	vtkNew<vtkActor> transformedActor;
	transformedActor->SetMapper(transformedMapper);
	//transformedActor->GetProperty()->SetColor(colors->GetColor3d("Red").GetData());

	// Set up the rest of the visualization pipeline

	//vtkNew<vtkRenderer> renderer;
	//renderer->AddActor(originalActor);
	renderer->AddActor(transformedActor);
	//renderer->SetBackground(colors->GetColor3d("Green").GetData());

	//vtkNew<vtkRenderWindow> renderWindow;
	renderWindow->AddRenderer(renderer);

	//vtkNew<vtkRenderWindowInteractor> renderWindowInteractor;
	//renderWindowInteractor->SetRenderWindow(renderWindow);

	//renderWindow->SetWindowName("TransformPolyData");
	//renderWindow->Render();
	//renderWindowInteractor->Start();
}


void Draw_Circle()
{
	double Raduis = sqrt(pow((picked[0] - picked2[0]), 2.0) + pow(picked[1] - picked2[1], 2.0));
	vtkSmartPointer<vtkPoints> Circle_points = vtkSmartPointer<vtkPoints>::New();
	int number_of_points = 120;
	Circle_lineSource->SetResolution(number_of_points);  //determines the quality of the generated line or polyline, with higher values of number_of_points leading to smoother and more precise lines.
	for (int i = 0; i <= number_of_points; i++)
	{
		double t_parameter = static_cast<double>(i) / number_of_points;   // division is performed using floating-point arithmetic rather than integer division.
		double x_circle = Scale_factor * (picked2[0] + Raduis * cos(2 * vtkMath::Pi() * t_parameter));
		double y_circle = Scale_factor * (picked2[1] + Raduis * sin(2 * vtkMath::Pi() * t_parameter));
		Circle_points->InsertNextPoint(x_circle, y_circle, 0.0);

	}

	Set_line_shape(Circle_lineSource, Circle_points, Circle_mapper, Circle_actor, renderer);


}

void Draw_Ellipse()
{

	double SemiMajorAxis = sqrt(pow((picked[0] - picked2[0]), 2.0) + pow((picked[1] - picked2[1]), 2.0));
	cout << "Major " << SemiMajorAxis << " ";
	double SemiMinorAxis = sqrt(pow((picked3[0] - picked2[0]), 2.0) + pow((picked3[1] - picked2[1]), 2.0));
	cout << "Minor " << SemiMinorAxis << " ";
	double axisRatio = SemiMajorAxis / SemiMinorAxis;
	cout << "ratio " << axisRatio << " ";
	vtkSmartPointer<vtkPoints> Ellipse_points = vtkSmartPointer<vtkPoints>::New();
	int number_of_points = 120;
	lineSource->SetResolution(number_of_points);


	//if (axisRatio >= 1) {
	SemiMajorAxis = sqrt(pow((picked3[0] - picked2[0]), 2.0) + pow(picked3[1] - picked2[1], 2.0));
	SemiMinorAxis = sqrt(pow((picked[0] - picked2[0]), 2.0) + pow(picked[1] - picked2[1], 2.0));
	cout << "first if";
	//}
	/*if(axisRatio<1) {
		SemiMajorAxis = sqrt(pow((picked[0] - picked2[0]), 2.0) + pow(picked[1] - picked2[1], 2.0));
		SemiMinorAxis = sqrt(pow((picked3[0] - picked2[0]), 2.0) + pow(picked3[1] - picked2[1], 2.0));
		cout << "AxisRatio<1";
	}*/

	for (int j = 0; j <= number_of_points; j++)
	{
		double x_ellipse;
		double y_ellipse;

		double t_parameter = static_cast<double>(j) / number_of_points;



		x_ellipse = Scale_factor*(picked2[0] + SemiMajorAxis * cos(2 * vtkMath::Pi() * (t_parameter + 0.25)));   //0.25?
		y_ellipse = Scale_factor*(picked2[1] + SemiMinorAxis * sin(2 * vtkMath::Pi() * (t_parameter + 0.25)));


		/*else if (axisRatio > 1) {
			x_ellipse = picked2[0] + SemiMajorAxis * sin(2 * vtkMath::Pi() * t_parameter)* sin(vtkMath::Pi() / 2);
			y_ellipse = picked2[1] + SemiMinorAxis *cos(2 * vtkMath::Pi() * t_parameter)*cos( vtkMath::Pi() / 2);
		}*/
		Ellipse_points->InsertNextPoint(x_ellipse, y_ellipse, 0.0);

	}



	Set_line_shape(Ellipse_lineSource, Ellipse_points, Ellipse_mapper, Ellipse_actor, renderer);
}

//Needs Modifications
void Draw_Arc()
{
	startAngle = M_PI_2;
	vtkSmartPointer<vtkPoints> Arc_points = vtkSmartPointer<vtkPoints>::New();

	int number_of_points = 120;

	lineSource->SetResolution(number_of_points);

	//double firstLine[3] = { picked3[0] - picked2[0], picked3[1] - picked2[1] };
	double firstLine[3] = { 0 - picked2[0], 1 - picked2[1],0 };
	double firstPoint[3] = { 0,1,0 };
	double Raduis = vtkMath::Distance2BetweenPoints(picked2, firstPoint);


	double secondLine[3] = { picked[0] - picked2[0], picked[1] - picked2[1],0 };
	double Raduis2 = vtkMath::Distance2BetweenPoints(picked2, picked);

	/*double horizontal[3] = { (picked2[0]+1) - picked2[0], picked2[1] - picked2[1] };
	double horizontalRaduis= sqrt(pow(horizontal[0], 2) + pow(horizontal[1], 2));*/

	/*if (picked2[1] < picked3[1]) {
		start_angle = acos((firstLine[0] * horizontal[0] + horizontal[1]* firstLine[1]);
	}*/

	double angle = acos(vtkMath::RadiansFromDegrees(firstLine[0] * secondLine[0] + firstLine[1] * secondLine[1])) / (Raduis2 * Raduis);
	/*if (picked[0] < picked3[0] && picked[1]>picked3[1]) {
		angle = 180;
	}
	if (picked3[0] < picked2[0] && picked3[1] < picked2[1]) {
		angle = -angle;
	}*/
	double Angle_increment = (angle) / (number_of_points - 1);
	for (int i = 0; i < number_of_points; i++)
	{
		double Current_angle = startAngle + Angle_increment * i;
		double x_arc = Scale_factor* (picked2[0] + Raduis2 * cos(Current_angle));
		double y_arc = Scale_factor* (picked2[1] + Raduis2 * sin(Current_angle));
		Arc_points->InsertNextPoint(x_arc, y_arc, 0.0);

	}

	Set_line_shape(Arc_lineSource, Arc_points, Arc_mapper, Arc_actor, renderer);
	renderWindow->Render();
}


void Draw_Regular_Polygon()
{
	vtkSmartPointer<vtkPoints> Regpolygon_points = vtkSmartPointer<vtkPoints>::New();
	int number_of_points = NumSides;
	lineSource->SetResolution(number_of_points);

	double Raduis_regpolygon = sqrt(pow((picked[0] - picked2[0]), 2.0) + pow(picked[1] - picked2[1], 2.0));

	double Angle_increment = 2 * vtkMath::Pi() / number_of_points;
	for (int point_indx = 0; point_indx <= number_of_points; point_indx++)
	{
		double Current_angle = Angle_increment * point_indx;
		double x_regpolygon = Scale_factor*(picked2[0] + Raduis_regpolygon * cos(Current_angle));
		double y_regpolygon = Scale_factor*(picked2[1] + Raduis_regpolygon * sin(Current_angle));
		Regpolygon_points->InsertNextPoint(x_regpolygon, y_regpolygon, 0.0);

	}
	Set_line_shape(Regpolygon_linesource, Regpolygon_points, Regpolygon_mapper, Regpolygon_actor, renderer);

}


bool ReadFile(char name[100]) {
	int i = 0;
	for (i; i < 101; i++) {
		if (name[i] == '\0')
		{
			break;
		}
	}
	name[i] = '.';
	name[i + 1] = 't';
	name[i + 2] = 'x';
	name[i + 3] = 't';
	name[i + 4] = '\0';

	int j = 0;

	while (name[j] != '\0') {

		cout << name[j];
		j++;
	}
	FILE* file;
	fopen_s(&file, name, "r");
	cout << "file to be read  " << file;
	if (file != NULL) {

		fscanf_s(file, "(%lf,%lf,%lf)\n(%lf,%lf,%lf) \n %d \n %s )", &x, &y, &z, &x2, &y2, &z2, &LineWidth, LineColor, sizeof(LineColor));

		printf("x: %lf, y: %lf, z: %lf\n", x, y, z);
		printf("x2: %lf, y2: %lf, z2: %lf\n", x2, y2, z2);
		printf("LineWidth: %d\n", LineWidth);
		printf("LineColor: %s\n", LineColor);
		cout << "picked= " << picked[1] << "picked2= " << picked2[1] << endl;
		//linestream << line;
		//linestream >> x >> y >> z;
		//if (counter ==1) {
		for (int i = 0; i < 3; i++) {
			if (i == 0) {
				picked[i] = x2;
				picked2[i] = x;
			}
			if (i == 1) {
				picked[i] = y2;
				picked2[i] = y;
			}
			if (i == 2) {
				picked[i] = z2;
				picked2[i] = z;
			}
		}
		fclose(file);



		// DrawLineOnce(); 
		return true;
	}
}


bool  WriteFile(string name) {

	fstream my_file;
	my_file.open(name, ios::out);
	if (!my_file) {
		cout << "File not created!";
	}
	else {
		cout << "File created successfully!";
		my_file << "(" << picked2[0] << "," << picked2[1] << "," << picked2[2] << ")" << endl << "(" << picked[0] << "," << picked[1] << "," << picked[2] << ")" << endl << LineWidth << endl << LineColor;
		my_file.close();
		cout << LineColor;
	}

	return true;


}

void DrawPoint() {

	for (int i = 0; i < 2; i++) {
		if (i == 0) {
			ss << "x= ";
		}
		if (i == 1) {
			ss << "y= ";
		}
		ss << picked[i] << ", ";
	}
	pt = ss.str();
	ss.str("");



	vtkNew<vtkNamedColors> colors;


	renderWindow->AddRenderer(renderer);
	renderWindowInteractor->SetRenderWindow(renderWindow);


	do {
		vtkSmartPointer <vtkTextWidget> textWidget = vtkSmartPointer<vtkTextWidget>::New();
		widget = 1;


	} while (widget == 0);



	textActor->SetInput(pt.c_str());

	//textActor->SetInput(floatString2.c_str());
   //textActor->SetInput(to_string(floatString));
	textActor->GetTextProperty()->SetColor(colors->GetColor3d("White").GetData());
	vtkSmartPointer<vtkTextRepresentation> textRepresentation = vtkSmartPointer<vtkTextRepresentation>::New();
	// vtkSmartPointer<vtkRenderWindowInteractor> interactor = vtkSmartPointer<vtkRenderWindowInteractor>::New();
	textRepresentation->GetPositionCoordinate()->SetValue(0.15, 0.15);
	textRepresentation->GetPosition2Coordinate()->SetValue(0.6, 0.18);
	textWidget->SetRepresentation(textRepresentation);

	textWidget->SetInteractor(renderWindowInteractor);
	textWidget->SetTextActor(textActor);
	textWidget->SelectableOff();



	textWidget->On();
	renderWindow->Render();

	//renderWindowInteractor->Start();


	return;
}
//Actor, colorcombobox
void change_color(QString color_chosen ,string selected_shape)
{
	//Shape_actor->GetProperty()->SetColor(colors->GetColor3d(color_chosen.toStdString()).GetData());

	if (selected_shape == "Circle")
	{
		Circle_actor->GetProperty()->SetColor(colors->GetColor3d(color_chosen.toStdString()).GetData());
		cout << "a33333333333";
	}
	else if (selected_shape == "Ellipse")
	{
		Ellipse_actor->GetProperty()->SetColor(colors->GetColor3d(color_chosen.toStdString()).GetData());

	}

	else if (selected_shape == "Polyline")
	{
		Polyline_actor->GetProperty()->SetColor(colors->GetColor3d(color_chosen.toStdString()).GetData());

	}

	else if (selected_shape == "Regular Polygon")
	{
		Regpolygon_actor->GetProperty()->SetColor(colors->GetColor3d(color_chosen.toStdString()).GetData());
	}

	else if (selected_shape == "Polygon")
	{
		Polygon_actor->GetProperty()->SetColor(colors->GetColor3d(color_chosen.toStdString()).GetData());

	}
	else if (selected_shape == "Arc")
	{
		Arc_actor->GetProperty()->SetColor(colors->GetColor3d(color_chosen.toStdString()).GetData());

	}
	else if (selected_shape == "Line")
	{
		actor->GetProperty()->SetColor(colors->GetColor3d(color_chosen.toStdString()).GetData());

	}


}




namespace {

	// Define interaction style
	class MouseInteractorStylePP : public vtkInteractorStyleTrackballCamera
	{
	public:

		static MouseInteractorStylePP* New();
		vtkTypeMacro(MouseInteractorStylePP, vtkInteractorStyleTrackballCamera);

		int flag = 0;

		virtual void OnLeftButtonDown() override
		{
			std::cout << "Picking pixel: " << this->Interactor->GetEventPosition()[0]
				<< " " << this->Interactor->GetEventPosition()[1] << std::endl;


			this->Interactor->GetPicker()->Pick(this->Interactor->GetEventPosition()[0],
				this->Interactor->GetEventPosition()[1],
				0, // always zero.
				this->Interactor->GetRenderWindow()
				->GetRenderers()
				->GetFirstRenderer());


			this->Interactor->GetPicker()->GetPickPosition(picked);

			std::cout << "Picked value: " << picked[0] << " " << picked[1] << " "
				<< picked[2] << std::endl;


			flag++;
			if (flag == 1) {


				for (int i = 0; i < 3; i++) {
					picked2[i] = picked[i];
				}
				if (isLine) {
					SetFirstPoint();
					SetSecondPoint();

					Shapes_drawn.insert("Line");

				}
				if (isPolyline) {
					if (countIsLine == 2) {
						for (int i = 0; i <= counterPoly; i++) {
							pointsArray[i][0] = 0;
							pointsArray[i][1] = 0;
							pointsArray[i][2] = 0;
						}
						counterPoly = -1;

					}
					Draw_Polyline();
					Shapes_drawn.insert("Polyline");
					renderWindow->Render();
					flag = 0;
				}
				if (isPolygon) {
					if (countIsPolygon == 2) {
						for (int i = 0; i <= counterPolygon; i++) {
							pointsArray[i][0] = 0;
							pointsArray[i][1] = 0;
							pointsArray[i][2] = 0;
						}

						counterPolygon = -1;

					}
					Draw_Polygon();
					Shapes_drawn.insert("Polygon");
					renderWindow->Render();
					flag = 0;
				}

				DrawPoint();
			}
			if (flag == 2) {
				for (int i = 0; i < 3; i++) {
					picked3[i] = picked[i];
				}
				if (isLine) {

					SetSecondPoint();
					flag = 0;
				}

				if (isRegularPolygon)
				{
					Draw_Regular_Polygon();
					Shapes_drawn.insert("Regular Polygon");

					renderWindow->Render();
					flag = 0;
					return;

				}
				if (isArc) {
					Draw_Arc();
					Shapes_drawn.insert("Arc");
					flag = 0;
				}



				std::cout << "Picked value: " << picked[0] << " " << picked[1] << " "
					<< picked[2] << std::endl;
				std::cout << "Picked2 value: " << picked2[0] << " " << picked2[1] << " "
					<< picked2[2] << std::endl;
				DrawPoint();

			}

			if (isCircle && flag == 2) {


				Draw_Circle();
				Shapes_drawn.insert("Circle");
				renderWindow->Render();
				//renderer->RemoveAllViewProps();
				//transformation(mapper, actor, 0, 0, 0);
				//renderWindow->Render();
				flag = 0;

				return;
			}
			if (isEllipse && flag == 3) {



				Draw_Ellipse();
				Shapes_drawn.insert("Ellipse");
				renderWindow->Render();
				flag = 0;

				return;
			}



			//}
			//if (clearPolyLine) {
			//	points->Delete();
			//	clearPolyLine = false;
			//	countPolyLinePoints = 0;
			//}

			vtkInteractorStyleTrackballCamera::OnLeftButtonDown();

		}



		// Forward events

	};

	vtkStandardNewMacro(MouseInteractorStylePP);
}


int main(int argc, char* argv[])
{
	
	QSurfaceFormat::setDefaultFormat(QVTKOpenGLNativeWidget::defaultFormat());   //line sets the default format for Qt surface to be used with VTK
	// The QSurfaceFormat is a class that defines the format for OpenGL surfaces. In this case, the QVTKOpenGLNativeWidget is used as the default format, which is a widget that provides a native OpenGL rendering context for VTK.

	QApplication app(argc, argv);  //creates QApplication object required for the Qt Application


	QMainWindow mainWindow;
	mainWindow.resize(1200, 900);
	QDockWidget controlDock;    // dockable widget attached to sides of main window
	// add the buttons to the main window
	QVBoxLayout* layout = new QVBoxLayout();//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	QWidget* centralWidget = new QWidget();
	centralWidget->setLayout(layout);
	mainWindow.setCentralWidget(centralWidget);
	//////////////////FOR LINE////////////////////
	QWidget layoutContainer;

	QPointer<QVTKOpenGLNativeWidget> vtkRenderWidget = new QVTKOpenGLNativeWidget();
	char read[100];
	QComboBox* color_comboBox = new QComboBox();

	QString selectedText;
	QSpinBox* spinBox = new QSpinBox();
	QDoubleSpinBox* Scaling_spinbox = new QDoubleSpinBox();
	QTextEdit* textBox = new QTextEdit();
	
	/*
	///////////////////////////////FOR POLYLINE/////////
	// Create a polydata to store everything in
	//draw normal polygon
	//QObject::connect(regPolygon, &QPushButton::clicked, [&]() {
	//	Line = false;
	//	polyL = false;
	//	regpoly = true;
	//	mainWindow.addDockWidget(Qt::LeftDockWidgetArea, &controlDock);
	//	QLabel controlDockTitle("Control Dock");
	//	controlDockTitle.setMargin(20);
	//	controlDock.setTitleBarWidget(&controlDockTitle);
	//	QPointer<QVBoxLayout> dockLayout = new QVBoxLayout();
	//	layoutContainer.setLayout(dockLayout);
	//	controlDock.setWidget(&layoutContainer);
	//	mainWindow.setCentralWidget(vtkRenderWidget);





	//	mapper->SetInputData(polyData);

	//	//vtkNew<vtkActor> actor;
	//	actor->SetMapper(mapper);
	//	actor->GetProperty()->SetColor(colors->GetColor3d("Tomato").GetData());
	//	renderer->SetBackground(namedColors->GetColor3d("black").GetData());
	//	renderWindow->SetWindowName("regular polygon");
	//	renderWindowInteractor->SetRenderWindow(renderWindow);
	//	renderer->AddActor(actor);
	//	renderWindow->SetInteractor(renderWindowInteractor);
	//	renderWindow->AddRenderer(renderer);
	//	renderWindow->SetInteractor(vtkRenderWidget->interactor());
	//	renderWindow->GetInteractor()->SetPicker(pointPicker);
	//	vtkNew<MouseInteractorStylePP> style;
	//	renderWindow->GetInteractor()->SetInteractorStyle(style);
	//	vtkRenderWidget->setRenderWindow(renderWindow);

	//	// Display the regular polygon
	//	renderWindow->Render();
	//	renderWindow->GetInteractor()->Start();
	//	mainWindow.show();

	//	});

	////draw polyline
	//QObject::connect(buttonPolyLine, &QPushButton::clicked, [&]() {
	//	Line = false;
	//	polyL = true;
	//	regpoly = false;

	//	mainWindow.addDockWidget(Qt::LeftDockWidgetArea, &controlDock);

	//	QLabel controlDockTitle("Control Dock");
	//	controlDockTitle.setMargin(20);
	//	controlDock.setTitleBarWidget(&controlDockTitle);

	//	QPointer<QVBoxLayout> dockLayout = new QVBoxLayout();

	//	layoutContainer.setLayout(dockLayout);
	//	controlDock.setWidget(&layoutContainer);


	//	mainWindow.setCentralWidget(vtkRenderWidget);




	//	polyLine->GetPointIds()->SetNumberOfIds(countPolyLinePoints);
	//	for (unsigned int i = 0; i < countPolyLinePoints; i++)
	//	{
	//		polyLine->GetPointIds()->SetId(i, i);
	//	}


	//	cells->InsertNextCell(polyLine);



	//	// Add the points to the dataset
	//	polyData->SetPoints(points);

	//	// Add the lines to the dataset
	//	polyData->SetLines(cells);

	//	// Setup actor and mapper

	//	mapper->SetInputData(polyData);

	//	//vtkNew<vtkActor> actor;
	//	actor->SetMapper(mapper);
	//	actor->GetProperty()->SetColor(colors->GetColor3d("Tomato").GetData());

	//	renderer->SetBackground(namedColors->GetColor3d("SlateGray").GetData());
	//	renderWindow->SetWindowName("PolyLine");

	//	renderWindowInteractor->SetRenderWindow(renderWindow);
	//	renderer->AddActor(actor);




	//	renderWindow->SetInteractor(renderWindowInteractor);


	//	renderWindow->AddRenderer(renderer);
	//	renderWindow->SetInteractor(vtkRenderWidget->interactor());

	//	renderWindow->GetInteractor()->SetPicker(pointPicker);
	//	vtkNew<MouseInteractorStylePP> style;
	//	renderWindow->GetInteractor()->SetInteractorStyle(style);



	//	vtkRenderWidget->setRenderWindow(renderWindow);


	//	// Display the line
	//	renderWindow->Render();


	//	renderWindow->GetInteractor()->Start();


	//	mainWindow.show();

	//	});



*/




		///////////////////////////////////////////////////////////////GUI LINE////////////////////////////////////////////
	mainWindow.addDockWidget(Qt::LeftDockWidgetArea, &controlDock);

	QLabel controlDockTitle("Control Dock");
	controlDockTitle.setMargin(20);
	controlDock.setTitleBarWidget(&controlDockTitle);

	QPointer<QVBoxLayout> dockLayout = new QVBoxLayout();

	layoutContainer.setLayout(dockLayout);
	controlDock.setWidget(&layoutContainer);

	////////////////////////////////////////////////////////////////////END//////////////////////////////////////

	///////////////////////////////////////////////////////////////COMBOBOX COLOUR LINE/////////////////////////////////////////



	color_comboBox->addItem("Black");
	color_comboBox->addItem("White");
	color_comboBox->addItem("Red");
	selectedText = color_comboBox->currentText();

	dockLayout->addWidget(color_comboBox);

	/////////////////////////////////////////////////////////////////END///////////////////////////////////////////////////

	////////////////////////////////////////////////////////SPINBOX LINE WIDTH///////////////////////////////////////

	spinBox->setMinimum(0);
	spinBox->setMaximum(100);
	spinBox->setSingleStep(1);
	spinBox->setValue(1);

	dockLayout->addWidget(spinBox);
	///////////////////////////////////////////////////////////////////////////////END/////////////////////////////////
	QComboBox* shape_comboBox = new QComboBox();

	///////////////////////////////////////////////////////////////COMBOBOX COMBOBOX SHAPE SELECT/////////////////////////////////////////
	shape_comboBox->addItem("Line");
	shape_comboBox->addItem("Polyline");
	shape_comboBox->addItem("Polygon");
	shape_comboBox->addItem("Regular Polygon");
	shape_comboBox->addItem("Circle");
	shape_comboBox->addItem("Arc");
	shape_comboBox->addItem("Ellipse");
	dockLayout->addWidget(shape_comboBox);

	QSpinBox* spinNumSides = new QSpinBox();
	QObject::connect(shape_comboBox, (&QComboBox::currentIndexChanged), [&]() {

		string selectedText = shape_comboBox->currentText().toStdString();

		switch (selectedText[0]) {
		case 'C':
			if (spinNumSides->value() != NULL) {
				dockLayout->removeWidget(spinNumSides);
			}
			isLine = 0;
			isEllipse = 0;
			isArc = 0;
			isRegularPolygon = 0;
			isPolygon = 0;
			isPolyline = 0;
			isCircle = 1;

			break;
		case 'L':
			if (spinNumSides->value() != NULL) {
				dockLayout->removeWidget(spinNumSides);
			}
			isLine = 1;
			isEllipse = 0;
			isArc = 0;
			isRegularPolygon = 0;
			isPolygon = 0;
			isPolyline = 0;
			isCircle = 0;
			

			break;

		case 'E':
			if (spinNumSides->value() != NULL) {
				dockLayout->removeWidget(spinNumSides);
			}
			isLine = 0;
			isEllipse = 1;
			isArc = 0;
			isRegularPolygon = 0;
			isPolygon = 0;
			isPolyline = 0;
			isCircle = 0;
		

			break;
		case 'R':
			isLine = 0;
			isEllipse = 0;
			isArc = 0;
			isRegularPolygon = 1;
			isPolygon = 0;
			isPolyline = 0;
			isCircle = 0;
		

			
			spinNumSides->setMinimum(0);
			spinNumSides->setMaximum(100);
			spinNumSides->setSingleStep(1);
			spinNumSides->setValue(NumSides);

			dockLayout->addWidget(spinNumSides);

			break;
		case 'A':
			if (spinNumSides->value() != NULL) {
				dockLayout->removeWidget(spinNumSides);
			}
			isLine = 0;
			isEllipse = 0;
			isArc = 1;
			isRegularPolygon = 0;
			isPolygon = 0;
			isPolyline = 0;
			isCircle = 0;


			break;
		case 'P':
			if (spinNumSides->value() != NULL) {
				dockLayout->removeWidget(spinNumSides);
			}
			if (selectedText[4] == 'l') {
				countIsLine++;
				isLine = 0;
				isEllipse = 0;
				isArc = 0;
				isRegularPolygon = 0;
				isPolygon = 0;
				isPolyline = 1;
				isCircle = 0;
			

				break;
			}
			else {
				if (spinNumSides->value() != NULL) {
					dockLayout->removeWidget(spinNumSides);
				}
				countIsPolygon++;
				isLine = 0;
				isEllipse = 0;
				isArc = 0;
				isRegularPolygon = 0;
				isPolygon = 1;
				isPolyline = 0;
				isCircle = 0;
		

				break;
			}
		}

		// update selectedText with the current selected item





		renderWindow->Render();
		});

	///////////////////////////////////////////////////////////////////////////////END/////////////////////////////////

	///////////////////////////////////////////////////////////////////READ WRITE BUTTONS////////////////////////////////////
	QPushButton* pushButton = new QPushButton("Read File");
	QPushButton* pushButton2 = new QPushButton("Write File");
	dockLayout->addWidget(pushButton);
	dockLayout->addWidget(pushButton2);

	/////////////////Scaling_spinbox///////////////////
	Scaling_spinbox->setMinimum(-5.0);
	Scaling_spinbox->setMaximum(5.0);
	Scaling_spinbox->setSingleStep(0.1);
	Scaling_spinbox->setValue(1.0);

	dockLayout->addWidget(Scaling_spinbox);


	////////////////////////End///////////////////////




	mainWindow.setCentralWidget(vtkRenderWidget);


	///////////////////////LINE/////////////////////////////


	//Draw_Circle(3);
//	Draw_Arc();
	//Draw_Ellipse();

	mapper->SetInputConnection(lineSource->GetOutputPort());
	mapper->Update();
	actor->GetProperty()->SetColor(colors->GetColor3d(selectedText.toStdString()).GetData());
	/*LineColor = selectedText.toStdString().c_str();
	actor->GetProperty()->SetLineWidth(spinBox->value());*/
	LineWidth = spinBox->value();
	actor->SetMapper(mapper);
	renderer->AddActor(actor);
	renderWindow->AddRenderer(renderer);

	//renderWindow->SetInteractor(renderWindowInteractor);


	/////////////////////////////////////////////////////READ PUSH BUTTON//////////////////////////////////////

	QObject::connect(pushButton, &QPushButton::released, [&]() {

		QString text2 = QInputDialog::getText(nullptr, "Input File Name to be Read", "File Name");
		qDebug() << "Input: " << text2;


		strcpy(read, text2.toStdString().c_str());


		ReadFile(read);
		spinBox->setValue(LineWidth);
		color_comboBox->setCurrentText(LineColor);
		vtkSmartPointer<vtkLineSource> lineSource = vtkSmartPointer<vtkLineSource>::New();
		actor->GetProperty()->SetLineWidth(LineWidth);
		actor->GetProperty()->SetColor(colors->GetColor3d(LineColor).GetData());
		SetFirstPoint();
		SetSecondPoint();
		lineSource->Update();
		cout << picked[1] << "                         " << picked2[1];
		mapper->Update();

		DrawPoint();





		});

	//////////////////////////////////////////////////////////////// END///////////////////////////////
	char test[100] = { 't','e','s','t' };
	ReadFile(test);

	SetFirstPoint();
	SetSecondPoint();

	////////////////////////////////////////////////////////////////WRITE PUSH BUTTON////////////////////////////////
	QObject::connect(pushButton2, &QPushButton::released, [&]() {
		QString text = QInputDialog::getText(nullptr, "Input File Name to be written", "File Name");
		qDebug() << "Input: " << text;
		string write;
		write = text.toStdString();
		write = write + ".txt";
		WriteFile(write);
		});

	//////////////////////////////////////////////////////////////////////END/////////////////////////////////////////////

	////////////////////////////////////////////SET READ VALUES (COLOUR AND WIDTH) IN COMBOBOX AND SPINBOX///////////////
	actor->GetProperty()->SetLineWidth(spinBox->value());
	cout << "color  " << selectedText.toStdString();
	cout << "Linewidth  " << spinBox->value();
	actor->GetProperty()->SetColor(colors->GetColor3d(selectedText.toStdString()).GetData());
	//////////////////////////////////////////////////////////END///////////////////////////////////////////////////////////



	renderer->SetBackground(namedColors->GetColor3d("SlateGray").GetData());
	///////////////////////////////////////////////////////////COMBOBOX WIDGET APPLIED/////////////////////////////////

	QObject::connect(color_comboBox, (&QComboBox::currentIndexChanged), [&]() {
		//Another function change color

		selectedText = color_comboBox->currentText();
		QMessageBox Color_changebox;
		Color_changebox.setText("                        Choose an option:");
		Color_changebox.setStandardButtons(QMessageBox::Ok | QMessageBox::Cancel);  

	    Color_changebox.addButton(QMessageBox::tr("All shapes"), QMessageBox::ActionRole);
		Color_changebox.addButton(QMessageBox::tr("Last Shape"), QMessageBox::ActionRole);

		

		QComboBox* Shapes_combobox = new QComboBox(&Color_changebox);

		for (const auto& shape : Shapes_drawn)
		{
			Shapes_combobox->addItem(QString::fromStdString(shape));
			
		}

		Color_changebox.exec(); 

	
		int result = Color_changebox.result();
		
		  
			if (result == 0)
			{
				//All shapes chosen
				for (const auto& shape : Shapes_drawn)   //loop on all the drawn shapes 
				{
					 string shape_str = shape; 

					change_color(selectedText, shape_str); 

				}

			}

			else if (result == 1)
			{
				//Last shape chosen
				if (!Shapes_drawn.empty())
				{
					string last_shape = *Shapes_drawn.rbegin(); // get the last shape drawn 
					change_color(selectedText, last_shape);
				}

			}

			else
			{
				//Shape from Dropdown list selected
				std::string selectedShape = Shapes_combobox->currentText().toStdString(); 
				change_color(selectedText, selectedShape);


			}

		


		
		

		
		
		// update selectedText with the current selected item
		//actor->GetProperty()->SetColor(colors->GetColor3d(selectedText.toStdString()).GetData());
        //qstrcpy(LineColor, qPrintable(selectedText));



		renderWindow->Render();
		});
	///////////////////////////////////////////////////////////END//////////////////////////////////////////////
	// 
	//////////////////////////////////////////////////////////////////////SPINBOX WIDGET APPLIED///////////////////////////////////
	QObject::connect(spinBox, static_cast<void(QSpinBox::*)(int)>(&QSpinBox::valueChanged), [&]() {
		actor->GetProperty()->SetLineWidth(spinBox->value());
		LineWidth = spinBox->value();
		renderWindow->Render();
		});
	QObject::connect(Scaling_spinbox, static_cast<void(QDoubleSpinBox::*)(double)>(&QDoubleSpinBox::valueChanged), [&]() {

		Scale_factor = Scaling_spinbox->value();
		if (isCircle)
		{
			Draw_Circle();
			renderWindow->Render();
		}
		else if (isRegularPolygon)
		{
			Draw_Regular_Polygon();
			renderWindow->Render();
		}

		else if (isArc)
		{
			Draw_Arc();
			renderWindow->Render();

		}
		
		else if (isEllipse)
		{
			Draw_Ellipse();
			renderWindow->Render();
		}

		});


	QObject::connect(spinNumSides, static_cast<void(QSpinBox::*)(int)>(&QSpinBox::valueChanged), [&]() {

		NumSides = spinNumSides->value();
		Draw_Regular_Polygon();
		renderWindow->Render();

		});
	/*QObject::connect(spinStartAngle, static_cast<void(QSpinBox::*)(int)>(&QSpinBox::valueChanged), [&]() {
		startAngle = spinStartAngle->value();
		Draw_Arc;
		renderWindow->Render();
		});
	QObject::connect(spinEndAngle, static_cast<void(QSpinBox::*)(int)>(&QSpinBox::valueChanged), [&]() {
		endAngle = spinEndAngle->value();
		Draw_Arc;
		renderWindow->Render();
		});*/
		////////////////////////////////////////////////////////////////////////////END/////////////////////////////

		///////////////////////////////////////////////RENDERING, RENDERER, RENDERWINDOW, INTERACTOR//////////////////
		//Connect renderWindowInteractor in ONLeftClick with current working interactor
		// 
		// 

	renderWindow->SetInteractor(renderWindowInteractor);


	renderWindow->AddRenderer(renderer);
	renderWindow->SetInteractor(vtkRenderWidget->interactor());

	renderWindow->GetInteractor()->SetPicker(pointPicker);
	vtkNew<MouseInteractorStylePP> style;
	renderWindow->GetInteractor()->SetInteractorStyle(style);



	vtkRenderWidget->setRenderWindow(renderWindow);


	// Display the line
	renderWindow->Render();


	renderWindow->GetInteractor()->Start();


	mainWindow.show();



	mainWindow.show();

	return app.exec();


}
