#include <vtkActor.h>
#include <vtkInteractorStyleTrackballCamera.h>
#include <vtkNamedColors.h>
#include <vtkNew.h>
#include <vtkObjectFactory.h>
#include <vtkPointPicker.h>
#include <vtkPolyDataMapper.h>
#include <vtkRegularPolygonSource.h>
#include <vtkProperty.h>
#include <vtkRenderWindow.h>
#include <vtkRenderWindowInteractor.h>
#include <vtkRenderer.h>
#include <vtkRendererCollection.h>
#include <vtkSphereSource.h>
#include <vtkSmartPointer.h>
#include <vtkRenderWindow.h>
#include <vtkRenderer.h>
#include <vtkRenderWindowInteractor.h>
#include <vtkInteractorStyleTrackballCamera.h>
#include <vtkPoints.h>
#include <vtkCellArray.h>
#include <vtkPolyData.h>
#include <vtkLineSource.h>
#include <vtkPicker.h>
#include <vtkTextActor.h>
#include <vtkTextWidget.h>
#include <vtkTextProperty.h>
#include <vtkTextRepresentation.h>
#include <vtkNamedColors.h>
#include <vtkActor.h>
#include <QWidget>
#include <vtkCommand.h>
#include <vtkCoordinate.h>
#include <vtkNamedColors.h>
#include <vtkNew.h>
#include <vtkPolyDataMapper.h>
#include <vtkProperty.h>
#include <vtkRenderWindow.h>
#include <vtkRenderWindowInteractor.h>
#include <vtkRenderer.h>
#include <vtkSphereSource.h>
#include <vtkTextActor.h>
#include <vtkTextProperty.h>
#include <vtkTextRepresentation.h>
#include <vtkTextWidget.h>
#include <string>
#include <sstream>
#include <iostream>
#include <fstream>
#include< stdio.h >
#include <vtkTexturedButtonRepresentation2D.h>
#include <vtkPNGReader.h>
#include <vtkButtonWidget.h>
#include <vtkImageData.h>
#include <vtkTexture.h>
#include <vtkImageViewer2.h>
#include <vtkNamedColors.h>
#include <vtkImageCanvasSource2D.h>
#include <vtkImageData.h>
#include <vtkImageDataGeometryFilter.h>
#include <QVTKOpenGLNativeWidget.h>
#include <vtkActor.h>
#include <vtkDataSetMapper.h>
#include <vtkDoubleArray.h>
#include <vtkGenericOpenGLRenderWindow.h>
#include <vtkPointData.h>
#include <vtkProperty.h>
#include <vtkRenderer.h>
#include <vtkSphereSource.h>
#include <vtkTubeFilter.h>
#include <QApplication>
#include <QDockWidget>
#include <QGridLayout>
#include <QLabel>
#include <QMainWindow>
#include <QPointer>
#include <QPushButton>
#include <QVBoxLayout>
#include <QObject>


#include <cmath>
#include <cstdlib>
#include <random>
#include <QWidget>
#include <vtkSmartPointer.h>
#include <vtkRenderWindow.h>

#include <QtCore/QObject>
#include <QtCore/QDebug>
#include <QtWidgets/QApplication>
#include <QtWidgets/QPushButton>
#include <QLineEdit>
#include <QInputDialog>
#include <QComboBox>
#include <QSpinBox>
#include <vtkActor.h>
#include <vtkInteractorStyleTrackballCamera.h>
#include <vtkNamedColors.h>
#include <vtkNew.h>
#include <vtkObjectFactory.h>
#include <vtkPointPicker.h>
#include <vtkPolyDataMapper.h>
#include <vtkProperty.h>
#include <vtkRenderWindow.h>
#include <vtkRenderWindowInteractor.h>
#include <vtkRenderer.h>
#include <vtkRendererCollection.h>
#include <vtkSphereSource.h>
#include <vtkSmartPointer.h>
#include <vtkRenderWindow.h>
#include <vtkRenderer.h>
#include <vtkRenderWindowInteractor.h>
#include <vtkInteractorStyleTrackballCamera.h>
#include <vtkPolyDataMapper.h>
#include <vtkActor.h>
#include <vtkProperty.h>
#include <vtkPoints.h>
#include <vtkCellArray.h>
#include <vtkPolyData.h>
#include <vtkLineSource.h>
#include <vtkPicker.h>
#include <vtkTextActor.h>
#include <vtkTextWidget.h>
#include <vtkTextProperty.h>
#include <vtkTextRepresentation.h>
#include <vtkNamedColors.h>
#include <vtkActor.h>
#include <QWidget>
#include <vtkCommand.h>
#include <vtkCoordinate.h>
#include <vtkNamedColors.h>
#include <vtkNew.h>
#include <vtkPolyDataMapper.h>
#include <vtkProperty.h>
#include <vtkRenderWindow.h>
#include <vtkRenderWindowInteractor.h>
#include <vtkRenderer.h>
#include <vtkSphereSource.h>
#include <vtkTextActor.h>
#include <vtkTextProperty.h>
#include <vtkTextRepresentation.h>
#include <vtkTextWidget.h>
#include <string>
#include <sstream>
#include <iostream>
#include <fstream>
#include< stdio.h >
#include <vtkTexturedButtonRepresentation2D.h>
#include <vtkPNGReader.h>
#include <vtkButtonWidget.h>
#include <vtkImageData.h>
#include <vtkTexture.h>
#include <vtkImageViewer2.h>
#include <vtkNamedColors.h>
#include <vtkImageCanvasSource2D.h>
#include <vtkImageData.h>
#include <vtkImageDataGeometryFilter.h>
#include <QVTKOpenGLNativeWidget.h>
#include <vtkActor.h>
#include <vtkDataSetMapper.h>
#include <vtkDoubleArray.h>
#include <vtkGenericOpenGLRenderWindow.h>
#include <vtkPointData.h>
#include <vtkProperty.h>
#include <vtkRenderer.h>
#include <vtkSphereSource.h>
#include <vtkTubeFilter.h>
#include <QApplication>
#include <QDockWidget>
#include <QGridLayout>
#include <QLabel>
#include <QMainWindow>
#include <QPointer>
#include <QPushButton>
#include <QVBoxLayout>
#include <QObject>
#include <vtkHexahedron.h>
#include <QTextEdit>

#include <vtkActor.h>
#include <vtkCellArray.h>
#include <vtkCellData.h>
#include <vtkDoubleArray.h>
#include <vtkNamedColors.h>
#include <vtkNew.h>
#include <vtkRegularPolygonSource.h>
#include <vtkPoints.h>
#include <vtkPolyData.h>
#include <vtkPolyDataMapper.h>
#include <vtkPolyLine.h>
#include <vtkProperty.h>
#include <vtkRenderWindow.h>
#include <vtkRenderWindowInteractor.h>
#include <vtkRenderer.h>

#include <cmath>
#include <cstdlib>
#include <random>
#include <QWidget>
#include <vtkSmartPointer.h>
#include <vtkRenderWindow.h>

#include <QtCore/QObject>
#include <QtCore/QDebug>
#include <QtWidgets/QApplication>
#include <QtWidgets/QPushButton>
#include <QLineEdit>
#include <QInputDialog>
#include <QComboBox>
#include <QSpinBox>
#include <vtkActor.h>
#include <vtkCamera.h>
#include <vtkCellArray.h>
#include <vtkDataSetMapper.h>
#include <vtkHexahedron.h>
#include <vtkNamedColors.h>
#include <vtkNew.h>
#include <vtkPoints.h>
#include <vtkProperty.h>
#include <vtkRenderWindow.h>
#include <vtkRenderWindowInteractor.h>
#include <vtkRenderer.h>
#include <vtkUnstructuredGrid.h>
//#include <vtkEventQtSlotConnect>
using namespace std;
bool widget = 0;
double picked[3];
double picked2[3] = {};

double x = 0, y = 0, z = 0, z2 = 0, x2 = 0, y2 = 0;

//double *xp=&x , *yp = &y, *zp = &z, *x2p = &x2, *y2p = &y2, *z2p = &z2;
int LineWidth = 1;
char LineColor[100];

//LineColor[0]='B';
vtkNew<vtkPointPicker> pointPicker;

vtkSmartPointer<vtkTextActor> textActor = vtkSmartPointer<vtkTextActor>::New();
vtkSmartPointer<vtkActor> actor = vtkSmartPointer<vtkActor>::New();
vtkSmartPointer<vtkLineSource> lineSource = vtkSmartPointer<vtkLineSource>::New();
std::stringstream ss;
vtkSmartPointer<vtkPolyDataMapper> mapper = vtkSmartPointer<vtkPolyDataMapper>::New();
vtkSmartPointer<vtkRenderer> renderer = vtkSmartPointer<vtkRenderer>::New();

// vtkSmartPointer<vtkRenderWindow> renderWindow = vtkSmartPointer<vtkRenderWindow>::New();
vtkSmartPointer<vtkGenericOpenGLRenderWindow> renderWindow = vtkSmartPointer<vtkGenericOpenGLRenderWindow>::New();

vtkNew<vtkRenderWindowInteractor> renderWindowInteractor;
vtkSmartPointer <vtkTextWidget> textWidget = vtkSmartPointer<vtkTextWidget>::New();
string pt;
string pt2;

bool polyL = false;
bool Line = false;
bool regpoly = false;
bool clearPolyLine = false;
bool circle = false;

int countPolyLinePoints = 0;

vtkSmartPointer<vtkPoints> points = vtkSmartPointer<vtkPoints>::New();
vtkSmartPointer<vtkPolyData> polyData = vtkSmartPointer <vtkPolyData>::New();
vtkSmartPointer<vtkPolyLine> polyLine = vtkSmartPointer<vtkPolyLine>::New();
vtkSmartPointer<vtkRegularPolygonSource> polygonSource = vtkSmartPointer<vtkRegularPolygonSource>::New();
vtkSmartPointer<vtkCellArray> cells = vtkSmartPointer<vtkCellArray>::New();

/////////////////////////////////////////Functions used by classes////////////////////////
//set the first point of the line
void SetFirstPoint() {

	lineSource->SetPoint1(picked2[0], picked2[1], picked2[2]);
	return;
}

//set the second point of the line
void SetSecondPoint() {

	lineSource->SetPoint2(picked[0], picked[1], picked[2]);
	//lineSource->Modified();
	lineSource->Update();
}


void InsertPolyPoint() {
	points->InsertNextPoint(picked[0], picked[1], picked[2]);
	std::cout << "Picked value of polyline: " << picked[0] << " " << picked[1] << " "
		<< picked[2] << std::endl;

}

void Set_line_shape(vtkLineSource* line,vtkPoints* points, vtkPolyDataMapper* mapper, vtkActor* actor, vtkRenderer *renderer)
{
	line->SetPoints(points);
	mapper->SetInputConnection(line->GetOutputPort());
	mapper->Update();
	actor->SetMapper(mapper);
	actor->GetProperty()->SetColor(1.0, 0.0, 0.0);
	actor->GetProperty()->SetLineWidth(3.0);

	renderer->AddActor(actor);
}

void Draw_Circle(double Raduis = 3)
{
	
	int number_of_points = 120; 
	lineSource->SetResolution(number_of_points);  //determines the quality of the generated line or polyline, with higher values of number_of_points leading to smoother and more precise lines.
	for (int i = 0; i <= number_of_points; i++)
	{
		double t_parameter = static_cast<double>(i) / number_of_points;   // division is performed using floating-point arithmetic rather than integer division.
		double x_circle = Raduis * cos(2 * vtkMath::Pi() * t_parameter);
		double y_circle = Raduis * sin(2 * vtkMath::Pi() * t_parameter);
		points->InsertNextPoint(x_circle, y_circle, 0.0);

	}

	Set_line_shape(lineSource, points, mapper, actor, renderer);

}

void Draw_Ellipse(double SemiMajorAxis = 4, double SemiMinorAxis = 2)
{
	int number_of_points = 120;
	lineSource->SetResolution(number_of_points); 
	for (int j = 0; j <= number_of_points; j++)
	{
		double t_parameter = static_cast<double>(j) / number_of_points; 
		double x_ellipse = SemiMajorAxis * cos(2 * vtkMath::Pi() * t_parameter);
		double y_ellipse = SemiMinorAxis * sin(2 * vtkMath::Pi() * t_parameter);
		points->InsertNextPoint(x_ellipse, y_ellipse, 0.0);

	}



	Set_line_shape(lineSource, points, mapper, actor, renderer);
}


void Draw_Arc(double Raduis =5, double Start_angle = 0 , double End_Angle = 90 )
{
	int number_of_points = 120; 
	lineSource->SetResolution(number_of_points);
	double Angle_increment = (End_Angle - Start_angle) / (number_of_points - 1);
	for (int i = 0; i < number_of_points; i++)
	{
		double Current_angle = Start_angle + Angle_increment * i; 
		double x_arc = Raduis * cos(vtkMath::RadiansFromDegrees(Current_angle));
		double y_arc = Raduis * sin(vtkMath::RadiansFromDegrees(Current_angle));
		points->InsertNextPoint(x_arc, y_arc, 0.0);

	}

	Set_line_shape(lineSource, points, mapper, actor, renderer);
}


bool ReadFile(char name[100]) {
	int i = 0;
	for (i; i < 101; i++) {
		if (name[i] == '\0')
		{
			break;
		}
	}
	name[i] = '.';
	name[i + 1] = 't';
	name[i + 2] = 'x';
	name[i + 3] = 't';
	name[i + 4] = '\0';

	int j = 0;

	while (name[j] != '\0') {

		cout << name[j];
		j++;
	}
	FILE* file;
	fopen_s(&file, name, "r");
	cout << "file to be read  " << file;
	if (file != NULL) {

		fscanf_s(file, "(%lf,%lf,%lf)\n(%lf,%lf,%lf) \n %d \n %s )", &x, &y, &z, &x2, &y2, &z2, &LineWidth, LineColor, sizeof(LineColor));

		printf("x: %lf, y: %lf, z: %lf\n", x, y, z);
		printf("x2: %lf, y2: %lf, z2: %lf\n", x2, y2, z2);
		printf("LineWidth: %d\n", LineWidth);
		printf("LineColor: %s\n", LineColor);
		cout << "picked= " << picked[1] << "picked2= " << picked2[1] << endl;
		//linestream << line;
		//linestream >> x >> y >> z;
		//if (counter ==1) {
		for (int i = 0; i < 3; i++) {
			if (i == 0) {
				picked[i] = x2;
				picked2[i] = x;
			}
			if (i == 1) {
				picked[i] = y2;
				picked2[i] = y;
			}
			if (i == 2) {
				picked[i] = z2;
				picked2[i] = z;
			}
		}
		fclose(file);



		// DrawLineOnce(); 
		return true;
	}
}


bool  WriteFile(string name) {

	fstream my_file;
	my_file.open(name, ios::out);
	if (!my_file) {
		cout << "File not created!";
	}
	else {
		cout << "File created successfully!";
		my_file << "(" << picked2[0] << "," << picked2[1] << "," << picked2[2] << ")" << endl << "(" << picked[0] << "," << picked[1] << "," << picked[2] << ")" << endl << LineWidth << endl << LineColor;
		my_file.close();
		cout << LineColor;
	}

	return true;


}

void DrawPoint() {

	for (int i = 0; i < 2; i++) {
		if (i == 0) {
			ss << "x= ";
		}
		if (i == 1) {
			ss << "y= ";
		}
		ss << picked[i] << ", ";
	}
	pt = ss.str();
	ss.str("");



	vtkNew<vtkNamedColors> colors;


	renderWindow->AddRenderer(renderer);
	renderWindowInteractor->SetRenderWindow(renderWindow);


	do {
		vtkSmartPointer <vtkTextWidget> textWidget = vtkSmartPointer<vtkTextWidget>::New();
		widget = 1;


	} while (widget == 0);



	textActor->SetInput(pt.c_str());

	//textActor->SetInput(floatString2.c_str());
   //textActor->SetInput(to_string(floatString));
	textActor->GetTextProperty()->SetColor(colors->GetColor3d("White").GetData());
	vtkSmartPointer<vtkTextRepresentation> textRepresentation = vtkSmartPointer<vtkTextRepresentation>::New();
	// vtkSmartPointer<vtkRenderWindowInteractor> interactor = vtkSmartPointer<vtkRenderWindowInteractor>::New();
	textRepresentation->GetPositionCoordinate()->SetValue(0.15, 0.15);
	textRepresentation->GetPosition2Coordinate()->SetValue(0.6, 0.18);
	textWidget->SetRepresentation(textRepresentation);

	textWidget->SetInteractor(renderWindowInteractor);
	textWidget->SetTextActor(textActor);
	textWidget->SelectableOff();



	textWidget->On();
	renderWindow->Render();

	//renderWindowInteractor->Start();


	return;
}






namespace {

	// Define interaction style
	class MouseInteractorStylePP : public vtkInteractorStyleTrackballCamera
	{
	public:

		static MouseInteractorStylePP* New();
		vtkTypeMacro(MouseInteractorStylePP, vtkInteractorStyleTrackballCamera);

		int flag = 0;

		virtual void OnLeftButtonDown() override
		{
			std::cout << "Picking pixel: " << this->Interactor->GetEventPosition()[0]
				<< " " << this->Interactor->GetEventPosition()[1] << std::endl;


			this->Interactor->GetPicker()->Pick(this->Interactor->GetEventPosition()[0],
				this->Interactor->GetEventPosition()[1],
				0, // always zero.
				this->Interactor->GetRenderWindow()
				->GetRenderers()
				->GetFirstRenderer());


			this->Interactor->GetPicker()->GetPickPosition(picked);

			std::cout << "Picked value: " << picked[0] << " " << picked[1] << " "
				<< picked[2] << std::endl;



			if (Line) {
				flag++;
				if (flag == 1) {


					for (int i = 0; i < 3; i++) {
						picked2[i] = picked[i];
					}
					SetFirstPoint();
					SetSecondPoint();
					DrawPoint();
				}
				if (flag == 2) {

					SetSecondPoint();
					flag = 0;



					std::cout << "Picked value: " << picked[0] << " " << picked[1] << " "
						<< picked[2] << std::endl;
					std::cout << "Picked2 value: " << picked2[0] << " " << picked2[1] << " "
						<< picked2[2] << std::endl;
					DrawPoint();

				}
			}
			else if (polyL) {
				countPolyLinePoints++;

				InsertPolyPoint();
				//polyData->SetPoints(points);
				polyData->Modified();
				mapper->Update();
				this->Interactor->GetRenderWindow()->Render();

				DrawPoint();
				return;


			}
			if (clearPolyLine) {
				points->Delete();
				clearPolyLine = false;
				countPolyLinePoints = 0;
			}

			vtkInteractorStyleTrackballCamera::OnLeftButtonDown();

		}



		// Forward events

	};

	vtkStandardNewMacro(MouseInteractorStylePP);
}


int main(int argc, char* argv[])
{
	vtkNew<vtkNamedColors> colors;
	vtkNew<vtkNamedColors> namedColors;
	QSurfaceFormat::setDefaultFormat(QVTKOpenGLNativeWidget::defaultFormat());   //line sets the default format for Qt surface to be used with VTK
	// The QSurfaceFormat is a class that defines the format for OpenGL surfaces. In this case, the QVTKOpenGLNativeWidget is used as the default format, which is a widget that provides a native OpenGL rendering context for VTK.

	QApplication app(argc, argv);  //creates QApplication object required for the Qt Application


	QMainWindow mainWindow;
	mainWindow.resize(1200, 900);
	QDockWidget controlDock;    // dockable widget attached to sides of main window
	// add the buttons to the main window
	QVBoxLayout* layout = new QVBoxLayout();//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	QWidget* centralWidget = new QWidget();
	centralWidget->setLayout(layout);
	mainWindow.setCentralWidget(centralWidget);
	//////////////////FOR LINE////////////////////
	QWidget layoutContainer;

	QPointer<QVTKOpenGLNativeWidget> vtkRenderWidget = new QVTKOpenGLNativeWidget();
	char read[100];
	QComboBox* color_comboBox = new QComboBox();
	QComboBox* shape_comboBox = new QComboBox();
	QString selectedText;
	QSpinBox* spinBox = new QSpinBox();
	QTextEdit* textBox = new QTextEdit();

	///////////////////////////////FOR POLYLINE/////////
	// Create a polydata to store everything in
	//draw normal polygon
	//QObject::connect(regPolygon, &QPushButton::clicked, [&]() {
	//	Line = false;
	//	polyL = false;
	//	regpoly = true;
	//	mainWindow.addDockWidget(Qt::LeftDockWidgetArea, &controlDock);
	//	QLabel controlDockTitle("Control Dock");
	//	controlDockTitle.setMargin(20);
	//	controlDock.setTitleBarWidget(&controlDockTitle);
	//	QPointer<QVBoxLayout> dockLayout = new QVBoxLayout();
	//	layoutContainer.setLayout(dockLayout);
	//	controlDock.setWidget(&layoutContainer);
	//	mainWindow.setCentralWidget(vtkRenderWidget);





	//	mapper->SetInputData(polyData);

	//	//vtkNew<vtkActor> actor;
	//	actor->SetMapper(mapper);
	//	actor->GetProperty()->SetColor(colors->GetColor3d("Tomato").GetData());
	//	renderer->SetBackground(namedColors->GetColor3d("black").GetData());
	//	renderWindow->SetWindowName("regular polygon");
	//	renderWindowInteractor->SetRenderWindow(renderWindow);
	//	renderer->AddActor(actor);
	//	renderWindow->SetInteractor(renderWindowInteractor);
	//	renderWindow->AddRenderer(renderer);
	//	renderWindow->SetInteractor(vtkRenderWidget->interactor());
	//	renderWindow->GetInteractor()->SetPicker(pointPicker);
	//	vtkNew<MouseInteractorStylePP> style;
	//	renderWindow->GetInteractor()->SetInteractorStyle(style);
	//	vtkRenderWidget->setRenderWindow(renderWindow);

	//	// Display the regular polygon
	//	renderWindow->Render();
	//	renderWindow->GetInteractor()->Start();
	//	mainWindow.show();

	//	});

	////draw polyline
	//QObject::connect(buttonPolyLine, &QPushButton::clicked, [&]() {
	//	Line = false;
	//	polyL = true;
	//	regpoly = false;

	//	mainWindow.addDockWidget(Qt::LeftDockWidgetArea, &controlDock);

	//	QLabel controlDockTitle("Control Dock");
	//	controlDockTitle.setMargin(20);
	//	controlDock.setTitleBarWidget(&controlDockTitle);

	//	QPointer<QVBoxLayout> dockLayout = new QVBoxLayout();

	//	layoutContainer.setLayout(dockLayout);
	//	controlDock.setWidget(&layoutContainer);


	//	mainWindow.setCentralWidget(vtkRenderWidget);




	//	polyLine->GetPointIds()->SetNumberOfIds(countPolyLinePoints);
	//	for (unsigned int i = 0; i < countPolyLinePoints; i++)
	//	{
	//		polyLine->GetPointIds()->SetId(i, i);
	//	}


	//	cells->InsertNextCell(polyLine);



	//	// Add the points to the dataset
	//	polyData->SetPoints(points);

	//	// Add the lines to the dataset
	//	polyData->SetLines(cells);

	//	// Setup actor and mapper

	//	mapper->SetInputData(polyData);

	//	//vtkNew<vtkActor> actor;
	//	actor->SetMapper(mapper);
	//	actor->GetProperty()->SetColor(colors->GetColor3d("Tomato").GetData());

	//	renderer->SetBackground(namedColors->GetColor3d("SlateGray").GetData());
	//	renderWindow->SetWindowName("PolyLine");

	//	renderWindowInteractor->SetRenderWindow(renderWindow);
	//	renderer->AddActor(actor);




	//	renderWindow->SetInteractor(renderWindowInteractor);


	//	renderWindow->AddRenderer(renderer);
	//	renderWindow->SetInteractor(vtkRenderWidget->interactor());

	//	renderWindow->GetInteractor()->SetPicker(pointPicker);
	//	vtkNew<MouseInteractorStylePP> style;
	//	renderWindow->GetInteractor()->SetInteractorStyle(style);



	//	vtkRenderWidget->setRenderWindow(renderWindow);


	//	// Display the line
	//	renderWindow->Render();


	//	renderWindow->GetInteractor()->Start();


	//	mainWindow.show();

	//	});







	
		///////////////////////////////////////////////////////////////GUI LINE////////////////////////////////////////////
		mainWindow.addDockWidget(Qt::LeftDockWidgetArea, &controlDock);

		QLabel controlDockTitle("Control Dock");
		controlDockTitle.setMargin(20);
		controlDock.setTitleBarWidget(&controlDockTitle);

		QPointer<QVBoxLayout> dockLayout = new QVBoxLayout();

		layoutContainer.setLayout(dockLayout);
		controlDock.setWidget(&layoutContainer);

		////////////////////////////////////////////////////////////////////END//////////////////////////////////////

		///////////////////////////////////////////////////////////////COMBOBOX COLOUR LINE/////////////////////////////////////////



		color_comboBox->addItem("Black");
		color_comboBox->addItem("White");
		color_comboBox->addItem("Red");
		selectedText = color_comboBox->currentText();

		dockLayout->addWidget(color_comboBox);

		/////////////////////////////////////////////////////////////////END///////////////////////////////////////////////////

		////////////////////////////////////////////////////////SPINBOX LINE WIDTH///////////////////////////////////////
		spinBox->setMinimum(0);
		spinBox->setMaximum(100);
		spinBox->setSingleStep(1);
		spinBox->setValue(1);

		dockLayout->addWidget(spinBox);
		///////////////////////////////////////////////////////////////////////////////END/////////////////////////////////
		

		///////////////////////////////////////////////////////////////COMBOBOX COMBOBOX SHAPE SELECT/////////////////////////////////////////
		shape_comboBox->addItem("Line");
		shape_comboBox->addItem("Polyline");
		shape_comboBox->addItem("Polygon");
		shape_comboBox->addItem("Regular Polygon");
		shape_comboBox->addItem("Circle");
		shape_comboBox->addItem("Arc");
		shape_comboBox->addItem("Ellipse");
		dockLayout->addWidget(shape_comboBox);
		///////////////////////////////////////////////////////////////////////////////END/////////////////////////////////

		///////////////////////////////////////////////////////////////////READ WRITE BUTTONS////////////////////////////////////
		QPushButton* pushButton = new QPushButton("Read File");
		QPushButton* pushButton2 = new QPushButton("Write File");
		dockLayout->addWidget(pushButton);
		dockLayout->addWidget(pushButton2);


		mainWindow.setCentralWidget(vtkRenderWidget);


		///////////////////////LINE/////////////////////////////

		
	
		//Draw_Circle(3);
		Draw_Arc();
		//Draw_Ellipse();
		mapper->SetInputConnection(lineSource->GetOutputPort());
		mapper->Update();
		actor->GetProperty()->SetColor(colors->GetColor3d(selectedText.toStdString()).GetData());
		/*LineColor = selectedText.toStdString().c_str();
		actor->GetProperty()->SetLineWidth(spinBox->value());*/
		LineWidth = spinBox->value();
		actor->SetMapper(mapper);
		renderer->AddActor(actor);
		renderWindow->AddRenderer(renderer);

		//renderWindow->SetInteractor(renderWindowInteractor);


		/////////////////////////////////////////////////////READ PUSH BUTTON//////////////////////////////////////

		QObject::connect(pushButton, &QPushButton::released, [&]() {

			QString text2 = QInputDialog::getText(nullptr, "Input File Name to be Read", "File Name");
			qDebug() << "Input: " << text2;


			strcpy(read, text2.toStdString().c_str());


			ReadFile(read);
			spinBox->setValue(LineWidth);
			color_comboBox->setCurrentText(LineColor);
			vtkSmartPointer<vtkLineSource> lineSource = vtkSmartPointer<vtkLineSource>::New();
			actor->GetProperty()->SetLineWidth(LineWidth);
			actor->GetProperty()->SetColor(colors->GetColor3d(LineColor).GetData());
			SetFirstPoint();
			SetSecondPoint();
			lineSource->Update();
			cout << picked[1] << "                         " << picked2[1];
			mapper->Update();

			DrawPoint();





			});

		//////////////////////////////////////////////////////////////// END///////////////////////////////
		char test[100] = { 't','e','s','t' };
		ReadFile(test);

		SetFirstPoint();
		SetSecondPoint();

		////////////////////////////////////////////////////////////////WRITE PUSH BUTTON////////////////////////////////
		QObject::connect(pushButton2, &QPushButton::released, [&]() {
			QString text = QInputDialog::getText(nullptr, "Input File Name to be written", "File Name");
			qDebug() << "Input: " << text;
			string write;
			write = text.toStdString();
			write = write + ".txt";
			WriteFile(write);
			});

		//////////////////////////////////////////////////////////////////////END/////////////////////////////////////////////

		////////////////////////////////////////////SET READ VALUES (COLOUR AND WIDTH) IN COMBOBOX AND SPINBOX///////////////
		actor->GetProperty()->SetLineWidth(spinBox->value());
		cout << "color  " << selectedText.toStdString();
		cout << "Linewidth  " << spinBox->value();
		actor->GetProperty()->SetColor(colors->GetColor3d(selectedText.toStdString()).GetData());
		//////////////////////////////////////////////////////////END///////////////////////////////////////////////////////////



		renderer->SetBackground(namedColors->GetColor3d("SlateGray").GetData());
		///////////////////////////////////////////////////////////COMBOBOX WIDGET APPLIED/////////////////////////////////

		QObject::connect(color_comboBox, (&QComboBox::currentIndexChanged), [&]() {


			selectedText = color_comboBox->currentText();


			// update selectedText with the current selected item
			actor->GetProperty()->SetColor(colors->GetColor3d(selectedText.toStdString()).GetData());
			qstrcpy(LineColor, qPrintable(selectedText));



			renderWindow->Render();
			});
		///////////////////////////////////////////////////////////END//////////////////////////////////////////////
		// 
		//////////////////////////////////////////////////////////////////////SPINBOX WIDGET APPLIED///////////////////////////////////
		QObject::connect(spinBox, static_cast<void(QSpinBox::*)(int)>(&QSpinBox::valueChanged), [&]() {
			actor->GetProperty()->SetLineWidth(spinBox->value());
			LineWidth = spinBox->value();
			renderWindow->Render();
			});
		////////////////////////////////////////////////////////////////////////////END/////////////////////////////


		///////////////////////////////////////////////RENDERING, RENDERER, RENDERWINDOW, INTERACTOR//////////////////
		//Connect renderWindowInteractor in ONLeftClick with current working interactor
		// 
		// 

		renderWindow->SetInteractor(renderWindowInteractor);


		renderWindow->AddRenderer(renderer);
		renderWindow->SetInteractor(vtkRenderWidget->interactor());

		renderWindow->GetInteractor()->SetPicker(pointPicker);
		vtkNew<MouseInteractorStylePP> style;
		renderWindow->GetInteractor()->SetInteractorStyle(style);



		vtkRenderWidget->setRenderWindow(renderWindow);


		// Display the line
		renderWindow->Render();


		renderWindow->GetInteractor()->Start();


		mainWindow.show();



	mainWindow.show();

	return app.exec();


}


