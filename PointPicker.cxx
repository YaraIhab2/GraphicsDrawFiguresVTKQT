#include <vtkActor.h>
#include <vtkInteractorStyleTrackballCamera.h>
#include <vtkNamedColors.h>
#include <vtkNew.h>
#include <vtkObjectFactory.h>
#include <vtkPointPicker.h>
#include <vtkPolyDataMapper.h>
#include <vtkRegularPolygonSource.h>
#include <vtkProperty.h>
#include <vtkRenderWindow.h>
#include <vtkRenderWindowInteractor.h>
#include <vtkRenderer.h>
#include <vtkRendererCollection.h>
#include <vtkSphereSource.h>
#include <vtkSmartPointer.h>
#include <vtkRenderWindow.h>
#include <vtkRenderer.h>
#include <vtkRenderWindowInteractor.h>
#include <vtkInteractorStyleTrackballCamera.h>
#include <vtkPoints.h>
#include <vtkCellArray.h>
#include <vtkPolyData.h>
#include <vtkLineSource.h>
#include <vtkPicker.h>
#include <vtkTextActor.h>
#include <vtkTextWidget.h>
#include <vtkTextProperty.h>
#include <vtkTextRepresentation.h>
#include <vtkNamedColors.h>
#include <vtkActor.h>
#include <QWidget>
#include <vtkCommand.h>
#include <vtkCoordinate.h>
#include <vtkNamedColors.h>
#include <vtkNew.h>
#include <vtkPolyDataMapper.h>
#include <vtkProperty.h>
#include <vtkRenderWindow.h>
#include <vtkRenderWindowInteractor.h>
#include <vtkRenderer.h>
#include <vtkSphereSource.h>
#include <vtkTextActor.h>
#include <vtkTextProperty.h>
#include <vtkTextRepresentation.h>
#include <vtkTextWidget.h>
#include <string>
#include <sstream>
#include <iostream>
#include <fstream>
#include< stdio.h >
#include <vtkTexturedButtonRepresentation2D.h>
#include <vtkPNGReader.h>
#include <vtkButtonWidget.h>
#include <vtkImageData.h>
#include <vtkTexture.h>
#include <vtkImageViewer2.h>
#include <vtkNamedColors.h>
#include <vtkImageCanvasSource2D.h>
#include <vtkImageData.h>
#include <vtkImageDataGeometryFilter.h>
#include <QVTKOpenGLNativeWidget.h>
#include <vtkActor.h>
#include <vtkDataSetMapper.h>
#include <vtkDoubleArray.h>
#include <vtkGenericOpenGLRenderWindow.h>
#include <vtkPointData.h>
#include <vtkProperty.h>
#include <vtkRenderer.h>
#include <vtkSphereSource.h>
#include <vtkTubeFilter.h>
#include <QApplication>
#include <QDockWidget>
#include <QGridLayout>
#include <QLabel>
#include <QMainWindow>
#include <QPointer>
#include <QPushButton>
#include <QVBoxLayout>
#include <QObject>


#include <cmath>
#include <cstdlib>
#include <random>
#include <QWidget>
#include <vtkSmartPointer.h>
#include <vtkRenderWindow.h>

#include <QtCore/QObject>
#include <QtCore/QDebug>
#include <QtWidgets/QApplication>
#include <QtWidgets/QPushButton>
#include <QLineEdit>
#include <QInputDialog>
#include <QComboBox>
#include <QSpinBox>
#include <vtkActor.h>
#include <vtkInteractorStyleTrackballCamera.h>
#include <vtkNamedColors.h>
#include <vtkNew.h>
#include <vtkObjectFactory.h>
#include <vtkPointPicker.h>
#include <vtkPolyDataMapper.h>
#include <vtkProperty.h>
#include <vtkRenderWindow.h>
#include <vtkRenderWindowInteractor.h>
#include <vtkRenderer.h>
#include <vtkRendererCollection.h>
#include <vtkSphereSource.h>
#include <vtkSmartPointer.h>
#include <vtkRenderWindow.h>
#include <vtkRenderer.h>
#include <vtkRenderWindowInteractor.h>
#include <vtkInteractorStyleTrackballCamera.h>
#include <vtkPolyDataMapper.h>
#include <vtkActor.h>
#include <vtkProperty.h>
#include <vtkPoints.h>
#include <vtkCellArray.h>
#include <vtkPolyData.h>
#include <vtkLineSource.h>
#include <vtkPicker.h>
#include <vtkTextActor.h>
#include <vtkTextWidget.h>
#include <vtkTextProperty.h>
#include <vtkTextRepresentation.h>
#include <vtkNamedColors.h>
#include <vtkActor.h>
#include <QWidget>
#include <vtkCommand.h>
#include <vtkCoordinate.h>
#include <vtkNamedColors.h>
#include <vtkNew.h>
#include <vtkPolyDataMapper.h>
#include <vtkProperty.h>
#include <vtkRenderWindow.h>
#include <vtkRenderWindowInteractor.h>
#include <vtkRenderer.h>
#include <vtkSphereSource.h>
#include <vtkTextActor.h>
#include <vtkTextProperty.h>
#include <vtkTextRepresentation.h>
#include <vtkTextWidget.h>
#include <string>
#include <sstream>
#include <iostream>
#include <fstream>
#include< stdio.h >
#include <vtkTexturedButtonRepresentation2D.h>
#include <vtkPNGReader.h>
#include <vtkButtonWidget.h>
#include <vtkImageData.h>
#include <vtkTexture.h>
#include <vtkImageViewer2.h>
#include <vtkNamedColors.h>
#include <vtkImageCanvasSource2D.h>
#include <vtkImageData.h>
#include <vtkImageDataGeometryFilter.h>
#include <QVTKOpenGLNativeWidget.h>
#include <vtkActor.h>
#include <vtkDataSetMapper.h>
#include <vtkDoubleArray.h>
#include <vtkGenericOpenGLRenderWindow.h>
#include <vtkPointData.h>
#include <vtkProperty.h>
#include <vtkRenderer.h>
#include <vtkSphereSource.h>
#include <vtkTubeFilter.h>
#include <QApplication>
#include <QDockWidget>
#include <QGridLayout>
#include <QLabel>
#include <QMainWindow>
#include <QPointer>
#include <QPushButton>
#include <QVBoxLayout>
#include <QObject>
#include <vtkHexahedron.h>
#include <QTextEdit>

#include <vtkActor.h>
#include <vtkCellArray.h>
#include <vtkCellData.h>
#include <vtkDoubleArray.h>
#include <vtkNamedColors.h>
#include <vtkNew.h>
#include <vtkRegularPolygonSource.h>
#include <vtkPoints.h>
#include <vtkPolyData.h>
#include <vtkPolyDataMapper.h>
#include <vtkPolyLine.h>
#include <vtkProperty.h>
#include <vtkRenderWindow.h>
#include <vtkRenderWindowInteractor.h>
#include <vtkRenderer.h>

#include <cmath>
#include <cstdlib>
#include <random>
#include <QWidget>
#include <vtkSmartPointer.h>
#include <vtkRenderWindow.h>

#include <QtCore/QObject>
#include <QtCore/QDebug>
#include <QtWidgets/QApplication>
#include <QtWidgets/QPushButton>
#include <QLineEdit>
#include <QInputDialog>
#include <QComboBox>
#include <QSpinBox>
#include <vtkActor.h>
#include <vtkCamera.h>
#include <vtkCellArray.h>
#include <vtkDataSetMapper.h>
#include <vtkHexahedron.h>
#include <vtkNamedColors.h>
#include <vtkNew.h>
#include <vtkPoints.h>
#include <vtkProperty.h>
#include <vtkRenderWindow.h>
#include <vtkRenderWindowInteractor.h>
#include <vtkRenderer.h>
#include <vtkUnstructuredGrid.h>
#include <cmath>
//#include <vtkEventQtSlotConnect>
using namespace std;
bool widget = 0;
double picked[3];
double picked2[3] = {};
double picked3[3] = {};
double x = 0, y = 0, z = 0, z2 = 0, x2 = 0, y2 = 0;

//double *xp=&x , *yp = &y, *zp = &z, *x2p = &x2, *y2p = &y2, *z2p = &z2;
int LineWidth = 1;
char LineColor[100];
int countIsPolygon=0;
int startAngle = 0;
int endAngle = 0;
//LineColor[0]='B';
vtkNew<vtkPointPicker> pointPicker;

vtkSmartPointer<vtkTextActor> textActor = vtkSmartPointer<vtkTextActor>::New();
vtkSmartPointer<vtkActor> actor = vtkSmartPointer<vtkActor>::New();
vtkSmartPointer<vtkLineSource> lineSource = vtkSmartPointer<vtkLineSource>::New();
std::stringstream ss;
vtkSmartPointer<vtkPolyDataMapper> mapper = vtkSmartPointer<vtkPolyDataMapper>::New();
vtkSmartPointer<vtkRenderer> renderer = vtkSmartPointer<vtkRenderer>::New();

// vtkSmartPointer<vtkRenderWindow> renderWindow = vtkSmartPointer<vtkRenderWindow>::New();
vtkSmartPointer<vtkGenericOpenGLRenderWindow> renderWindow = vtkSmartPointer<vtkGenericOpenGLRenderWindow>::New();

vtkNew<vtkRenderWindowInteractor> renderWindowInteractor;
vtkSmartPointer <vtkTextWidget> textWidget = vtkSmartPointer<vtkTextWidget>::New();
string pt;
string pt2;

bool polyL = false;
bool Line = true;
bool regpoly = false;
bool clearPolyLine = false;
bool circle = false;
int NumSides = 5;
int countPolyLinePoints = 0;

vtkSmartPointer<vtkPoints> points = vtkSmartPointer<vtkPoints>::New();

vtkSmartPointer<vtkPolyData> polyData = vtkSmartPointer <vtkPolyData>::New();
vtkSmartPointer<vtkPolyLine> polyLine = vtkSmartPointer<vtkPolyLine>::New();
vtkSmartPointer<vtkRegularPolygonSource> polygonSource = vtkSmartPointer<vtkRegularPolygonSource>::New();
vtkSmartPointer<vtkCellArray> cells = vtkSmartPointer<vtkCellArray>::New();
int countIsLine = 0;
bool isCircle = 0;
bool isEllipse = 0;
bool isArc = 0;
bool isRegularPolygon = 0;
bool isPolygon = 0;
bool isPolyline = 0;
bool isLine = 1;
double pointsArray[100][3];
/////////////////////////////////////////Functions used by classes////////////////////////
//set the first point of the line
void SetFirstPoint() {

	lineSource->SetPoint1(picked2[0], picked2[1], picked2[2]);
	return;
}

//set the second point of the line
void SetSecondPoint() {

	lineSource->SetPoint2(picked[0], picked[1], picked[2]);
	//lineSource->Modified();
	lineSource->Update();
}


void InsertPolyPoint() {
	points->InsertNextPoint(picked[0], picked[1], picked[2]);
	std::cout << "Picked value of polyline: " << picked[0] << " " << picked[1] << " "
		<< picked[2] << std::endl;

}

void Set_line_shape(vtkLineSource* line, vtkPoints* points, vtkPolyDataMapper* mapper, vtkActor* actor, vtkRenderer* renderer)
{
	line->SetPoints(points);
	mapper->SetInputConnection(line->GetOutputPort());
	mapper->Update();
	actor->SetMapper(mapper);
	actor->GetProperty()->SetColor(1.0, 0.0, 0.0);
	actor->GetProperty()->SetLineWidth(3.0);

	renderer->AddActor(actor);
}
int counterPoly = -1;
int counterPolygon = -1;
void Draw_Polyline() {
	
	vtkSmartPointer<vtkPoints> points = vtkSmartPointer<vtkPoints>::New();
	counterPoly++;
	countIsLine = 1;
	//points->InsertNextPoint(picked[0], picked[1], 0);
	//vtkSmartPointer<vtkPoints> point1 = vtkSmartPointer<vtkPoints>::New();
	////point1=points->GetPoint(0);

	//vtkSmartPointer<vtkPoints> newPoints = vtkSmartPointer<vtkPoints>::New();
	//newPoints->DeepCopy(points);
	
	pointsArray[counterPoly][0] = picked[0];
	pointsArray[counterPoly][1] = picked[1];
	pointsArray[counterPoly][2] = 0;
	//pointsArray[i].Take(point1);
	
	for (int j = 0; j <= counterPoly;j++) {
		points->InsertNextPoint(pointsArray[j][0], pointsArray[j][1], 0);

	}
	//lineSource->SetPoints(points);
	//mapper->SetInputConnection(lineSource->GetOutputPort());
	//mapper->Update();
	//actor->SetMapper(mapper);
	////actor->GetProperty()->SetColor(LineColor);
	//renderer->AddActor(actor);
	//renderWindow->AddRenderer(renderer);
	Set_line_shape(lineSource, points, mapper, actor, renderer);
	renderWindow->AddRenderer(renderer);
	renderWindow->Render();
	/*renderWindowInteractor->SetRenderWindow(renderWindow);*/


}
void Draw_Polygon() {

	vtkSmartPointer<vtkPoints> points = vtkSmartPointer<vtkPoints>::New();
	counterPolygon++;
	countIsPolygon = 1;
	//points->InsertNextPoint(picked[0], picked[1], 0);
	//vtkSmartPointer<vtkPoints> point1 = vtkSmartPointer<vtkPoints>::New();
	////point1=points->GetPoint(0);

	//vtkSmartPointer<vtkPoints> newPoints = vtkSmartPointer<vtkPoints>::New();
	//newPoints->DeepCopy(points);

	pointsArray[counterPolygon][0] = picked[0];
	pointsArray[counterPolygon][1] = picked[1];
	pointsArray[counterPolygon][2] = 0;
	//pointsArray[i].Take(point1);

	for (int j = 0; j <= counterPolygon; j++) {
		/*if ((counterPolygon != 0) && j==counterPolygon-1) {
			pointsArray[counterPolygon][0] = 0;
			pointsArray[counterPolygon][1] = 0;
			pointsArray[counterPolygon][2] = 0;
			
		}*/
		points->InsertNextPoint(pointsArray[j][0], pointsArray[j][1], 0);
		if (j == counterPolygon) {
			points->InsertNextPoint(pointsArray[0][0], pointsArray[0][1], 0);
		}
	}
	lineSource->SetPoints(points);
	mapper->SetInputConnection(lineSource->GetOutputPort());
	mapper->Update();
	                 // renderer->Render();
	actor->SetMapper(mapper);
	
	//actor->GetProperty()->SetColor(LineColor);
	renderer->AddActor(actor);
	               //       renderer->Render();
	//renderWindow->AddRenderer(renderer);
	
	//mapper->Update();
	//Set_line_shape(lineSource, points, mapper, actor, renderer);
	//mapper->Update();
	renderWindow->AddRenderer(renderer);
	renderWindow->Render();
	//renderer->RemoveAllViewProps();
	//renderWindowInteractor->SetRenderWindow(renderWindow);

}
void Draw_Circle()
{
	double Raduis = sqrt(pow((picked[0] - picked2[0]),2.0) + pow(picked[1] - picked2[1], 2.0));
	vtkSmartPointer<vtkPoints> Circle_points = vtkSmartPointer<vtkPoints>::New();
	int number_of_points = 120;
	lineSource->SetResolution(number_of_points);  //determines the quality of the generated line or polyline, with higher values of number_of_points leading to smoother and more precise lines.
	for (int i = 0; i <= number_of_points; i++)
	{
		double t_parameter = static_cast<double>(i) / number_of_points;   // division is performed using floating-point arithmetic rather than integer division.
		double x_circle = picked2[0]+Raduis * cos(2 * vtkMath::Pi() * t_parameter);
		double y_circle =picked2[1]+ Raduis * sin(2 * vtkMath::Pi() * t_parameter);
		Circle_points->InsertNextPoint(x_circle, y_circle, 0.0);
		
	}
	
	Set_line_shape(lineSource, Circle_points, mapper, actor, renderer);
	

}

void Draw_Ellipse()
{
	
	double SemiMajorAxis = sqrt(pow((picked[0] - picked2[0]), 2.0) + pow((picked[1] - picked2[1]), 2.0));
	cout << "Major " << SemiMajorAxis << " ";
	double SemiMinorAxis =  sqrt(pow((picked3[0] - picked2[0]), 2.0) + pow((picked3[1] - picked2[1]), 2.0));
	cout << "Minor " << SemiMinorAxis << " ";
	double axisRatio = SemiMajorAxis / SemiMinorAxis;
	cout << "ratio " << axisRatio << " ";
	vtkSmartPointer<vtkPoints> Ellipse_points = vtkSmartPointer<vtkPoints>::New();
	int number_of_points = 120;
	lineSource->SetResolution(number_of_points);

	
	//if (axisRatio >= 1) {
		SemiMajorAxis = sqrt(pow((picked3[0] - picked2[0]), 2.0) + pow(picked3[1] - picked2[1], 2.0));
		SemiMinorAxis = sqrt(pow((picked[0] - picked2[0]), 2.0) + pow(picked[1] - picked2[1], 2.0));
		cout << "first if";
	//}
	/*if(axisRatio<1) {
		SemiMajorAxis = sqrt(pow((picked[0] - picked2[0]), 2.0) + pow(picked[1] - picked2[1], 2.0));
		SemiMinorAxis = sqrt(pow((picked3[0] - picked2[0]), 2.0) + pow(picked3[1] - picked2[1], 2.0));
		cout << "AxisRatio<1";
	}*/

	for (int j = 0; j <= number_of_points; j++)
	{
		double x_ellipse;
		double y_ellipse;

		double t_parameter = static_cast<double>(j) / number_of_points;
		
		

		 x_ellipse = picked2[0] + SemiMajorAxis * cos(2 * vtkMath::Pi() * (t_parameter+0.25)) ;
		 y_ellipse = picked2[1] + SemiMinorAxis * sin(2 * vtkMath::Pi() * (t_parameter+0.25));

		
		/*else if (axisRatio > 1) {
			x_ellipse = picked2[0] + SemiMajorAxis * sin(2 * vtkMath::Pi() * t_parameter)* sin(vtkMath::Pi() / 2);
			y_ellipse = picked2[1] + SemiMinorAxis *cos(2 * vtkMath::Pi() * t_parameter)*cos( vtkMath::Pi() / 2);
		}*/
		Ellipse_points->InsertNextPoint(x_ellipse, y_ellipse, 0.0);

	}



	Set_line_shape(lineSource, Ellipse_points, mapper, actor, renderer);
}


void Draw_Arc()
{
	startAngle = M_PI_2;
	vtkSmartPointer<vtkPoints> Arc_points = vtkSmartPointer<vtkPoints>::New();

	int number_of_points = 120;

	lineSource->SetResolution(number_of_points);

	//double firstLine[3] = { picked3[0] - picked2[0], picked3[1] - picked2[1] };
	double firstLine[3] = { 0 - picked2[0], 1 - picked2[1],0 };
	double firstPoint[3] = { 0,1,0 };
	double Raduis = vtkMath::Distance2BetweenPoints(picked2,firstPoint );
	
	
	double secondLine[3] = { picked[0] - picked2[0], picked[1] - picked2[1],0 };
	double Raduis2 = vtkMath::Distance2BetweenPoints(picked2, picked);
	
	/*double horizontal[3] = { (picked2[0]+1) - picked2[0], picked2[1] - picked2[1] };
	double horizontalRaduis= sqrt(pow(horizontal[0], 2) + pow(horizontal[1], 2));*/
	
	/*if (picked2[1] < picked3[1]) {
		start_angle = acos((firstLine[0] * horizontal[0] + horizontal[1]* firstLine[1]);
	}*/

	double angle=acos(vtkMath::RadiansFromDegrees(firstLine[0]*secondLine[0]+firstLine[1]*secondLine[1]))/(Raduis2*Raduis);
	/*if (picked[0] < picked3[0] && picked[1]>picked3[1]) {


		angle = 180;

	}
	if (picked3[0] < picked2[0] && picked3[1] < picked2[1]) {


		angle = -angle;
	}*/
	double Angle_increment = (angle) / (number_of_points - 1);
	for (int i = 0; i < number_of_points; i++)
	{
		double Current_angle = startAngle + Angle_increment * i;
		double x_arc = picked2[0]+Raduis2 * cos(Current_angle);
		double y_arc = picked2[1]+Raduis2 * sin(Current_angle);
		Arc_points->InsertNextPoint(x_arc, y_arc, 0.0);

	}

	Set_line_shape(lineSource, Arc_points, mapper, actor, renderer);
	renderWindow->Render();
}


void Draw_Regular_Polygon()
{
	vtkSmartPointer<vtkPoints> Regpolygon_points = vtkSmartPointer<vtkPoints>::New();
	int number_of_points = NumSides;
	lineSource->SetResolution(number_of_points);

	double Raduis_regpolygon = sqrt(pow((picked[0] - picked2[0]), 2.0) + pow(picked[1] - picked2[1], 2.0));

	double Angle_increment = 2 * vtkMath::Pi() / number_of_points;
	for (int point_indx = 0; point_indx <= number_of_points; point_indx++)
	{
		double Current_angle = Angle_increment * point_indx;
		double x_regpolygon = picked2[0] + Raduis_regpolygon * cos(Current_angle);
		double y_regpolygon = picked2[1] + Raduis_regpolygon * sin(Current_angle);
		Regpolygon_points->InsertNextPoint(x_regpolygon, y_regpolygon, 0.0);

	}
	Set_line_shape(lineSource, Regpolygon_points, mapper, actor, renderer);

}


bool ReadFile(char name[100]) {
	int i = 0;
	for (i; i < 101; i++) {
		if (name[i] == '\0')
		{
			break;
		}
	}
	name[i] = '.';
	name[i + 1] = 't';
	name[i + 2] = 'x';
	name[i + 3] = 't';
	name[i + 4] = '\0';

	int j = 0;

	while (name[j] != '\0') {

		cout << name[j];
		j++;
	}
	FILE* file;
	fopen_s(&file, name, "r");
	cout << "file to be read  " << file;
	if (file != NULL) {

		fscanf_s(file, "(%lf,%lf,%lf)\n(%lf,%lf,%lf) \n %d \n %s )", &x, &y, &z, &x2, &y2, &z2, &LineWidth, LineColor, sizeof(LineColor));

		printf("x: %lf, y: %lf, z: %lf\n", x, y, z);
		printf("x2: %lf, y2: %lf, z2: %lf\n", x2, y2, z2);
		printf("LineWidth: %d\n", LineWidth);
		printf("LineColor: %s\n", LineColor);
		cout << "picked= " << picked[1] << "picked2= " << picked2[1] << endl;
		//linestream << line;
		//linestream >> x >> y >> z;
		//if (counter ==1) {
		for (int i = 0; i < 3; i++) {
			if (i == 0) {
				picked[i] = x2;
				picked2[i] = x;
			}
			if (i == 1) {
				picked[i] = y2;
				picked2[i] = y;
			}
			if (i == 2) {
				picked[i] = z2;
				picked2[i] = z;
			}
		}
		fclose(file);



		// DrawLineOnce(); 
		return true;
	}
}


bool  WriteFile(string name) {

	fstream my_file;
	my_file.open(name, ios::out);
	if (!my_file) {
		cout << "File not created!";
	}
	else {
		cout << "File created successfully!";
		my_file << "(" << picked2[0] << "," << picked2[1] << "," << picked2[2] << ")" << endl << "(" << picked[0] << "," << picked[1] << "," << picked[2] << ")" << endl << LineWidth << endl << LineColor;
		my_file.close();
		cout << LineColor;
	}

	return true;


}

void DrawPoint() {

	for (int i = 0; i < 2; i++) {
		if (i == 0) {
			ss << "x= ";
		}
		if (i == 1) {
			ss << "y= ";
		}
		ss << picked[i] << ", ";
	}
	pt = ss.str();
	ss.str("");



	vtkNew<vtkNamedColors> colors;


	renderWindow->AddRenderer(renderer);
	renderWindowInteractor->SetRenderWindow(renderWindow);


	do {
		vtkSmartPointer <vtkTextWidget> textWidget = vtkSmartPointer<vtkTextWidget>::New();
		widget = 1;


	} while (widget == 0);



	textActor->SetInput(pt.c_str());

	//textActor->SetInput(floatString2.c_str());
   //textActor->SetInput(to_string(floatString));
	textActor->GetTextProperty()->SetColor(colors->GetColor3d("White").GetData());
	vtkSmartPointer<vtkTextRepresentation> textRepresentation = vtkSmartPointer<vtkTextRepresentation>::New();
	// vtkSmartPointer<vtkRenderWindowInteractor> interactor = vtkSmartPointer<vtkRenderWindowInteractor>::New();
	textRepresentation->GetPositionCoordinate()->SetValue(0.15, 0.15);
	textRepresentation->GetPosition2Coordinate()->SetValue(0.6, 0.18);
	textWidget->SetRepresentation(textRepresentation);

	textWidget->SetInteractor(renderWindowInteractor);
	textWidget->SetTextActor(textActor);
	textWidget->SelectableOff();



	textWidget->On();
	renderWindow->Render();

	//renderWindowInteractor->Start();


	return;
}






namespace {

	// Define interaction style
	class MouseInteractorStylePP : public vtkInteractorStyleTrackballCamera
	{
	public:

		static MouseInteractorStylePP* New();
		vtkTypeMacro(MouseInteractorStylePP, vtkInteractorStyleTrackballCamera);

		int flag = 0;

		virtual void OnLeftButtonDown() override
		{
			std::cout << "Picking pixel: " << this->Interactor->GetEventPosition()[0]
				<< " " << this->Interactor->GetEventPosition()[1] << std::endl;


			this->Interactor->GetPicker()->Pick(this->Interactor->GetEventPosition()[0],
				this->Interactor->GetEventPosition()[1],
				0, // always zero.
				this->Interactor->GetRenderWindow()
				->GetRenderers()
				->GetFirstRenderer());


			this->Interactor->GetPicker()->GetPickPosition(picked);

			std::cout << "Picked value: " << picked[0] << " " << picked[1] << " "
				<< picked[2] << std::endl;
			
			
			flag++;
			if (flag == 1) {


				for (int i = 0; i < 3; i++) {
					picked2[i] = picked[i];
				}
				if (isLine) {
					SetFirstPoint();
					SetSecondPoint();
					
				}
				if (isPolyline) {
					if (countIsLine ==2) {
						for (int i = 0; i <= counterPoly; i++) {
							pointsArray[i][0] = 0;
							pointsArray[i][1] = 0;
							pointsArray[i][2] = 0;
						}
						counterPoly = -1;
						
					}
					Draw_Polyline();
					renderWindow->Render();
					flag = 0;
				}
				if (isPolygon) {
					if (countIsPolygon ==2  ) {
						for (int i = 0; i <= counterPolygon; i++) {
							pointsArray[i][0] = 0;
							pointsArray[i][1] = 0;
							pointsArray[i][2] = 0;
						}
						
						counterPolygon = -1;
						
					}
					Draw_Polygon();
					renderWindow->Render();
					flag = 0;
				}
				
				DrawPoint();
			}
			if (flag == 2) {
				for (int i = 0; i < 3; i++) {
					picked3[i] = picked[i];
				}
				if (isLine) {

					SetSecondPoint();
					flag = 0;
				}
				
				if (isRegularPolygon)
				{
					Draw_Regular_Polygon();
					renderWindow->Render();
					flag = 0;
					return;

				}
				if (isArc) {
					Draw_Arc();
					flag = 0;
				}
				


				std::cout << "Picked value: " << picked[0] << " " << picked[1] << " "
					<< picked[2] << std::endl;
				std::cout << "Picked2 value: " << picked2[0] << " " << picked2[1] << " "
					<< picked2[2] << std::endl;
				DrawPoint();

			}

			if (isCircle &&flag==2) {
				

				Draw_Circle();
				renderWindow->Render();
				flag = 0;

				return;
			}
			if (isEllipse && flag == 3) {



				Draw_Ellipse();
				renderWindow->Render();
				flag = 0;

				return;
			}
			


			//}
			//if (clearPolyLine) {
			//	points->Delete();
			//	clearPolyLine = false;
			//	countPolyLinePoints = 0;
			//}

			vtkInteractorStyleTrackballCamera::OnLeftButtonDown();

		}



		// Forward events

	};

	vtkStandardNewMacro(MouseInteractorStylePP);
}


int main(int argc, char* argv[])
{
	vtkNew<vtkNamedColors> colors;
	vtkNew<vtkNamedColors> namedColors;
	QSurfaceFormat::setDefaultFormat(QVTKOpenGLNativeWidget::defaultFormat());   //line sets the default format for Qt surface to be used with VTK
	// The QSurfaceFormat is a class that defines the format for OpenGL surfaces. In this case, the QVTKOpenGLNativeWidget is used as the default format, which is a widget that provides a native OpenGL rendering context for VTK.

	QApplication app(argc, argv);  //creates QApplication object required for the Qt Application


	QMainWindow mainWindow;
	mainWindow.resize(1200, 900);
	QDockWidget controlDock;    // dockable widget attached to sides of main window
	// add the buttons to the main window
	QVBoxLayout* layout = new QVBoxLayout();//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	QWidget* centralWidget = new QWidget();
	centralWidget->setLayout(layout);
	mainWindow.setCentralWidget(centralWidget);
	//////////////////FOR LINE////////////////////
	QWidget layoutContainer;

	QPointer<QVTKOpenGLNativeWidget> vtkRenderWidget = new QVTKOpenGLNativeWidget();
	char read[100];
	QComboBox* color_comboBox = new QComboBox();
	
	QString selectedText;
	QSpinBox* spinBox = new QSpinBox();
	QTextEdit* textBox = new QTextEdit();
	
	///////////////////////////////FOR POLYLINE/////////
	// Create a polydata to store everything in
	//draw normal polygon
	//QObject::connect(regPolygon, &QPushButton::clicked, [&]() {
	//	Line = false;
	//	polyL = false;
	//	regpoly = true;
	//	mainWindow.addDockWidget(Qt::LeftDockWidgetArea, &controlDock);
	//	QLabel controlDockTitle("Control Dock");
	//	controlDockTitle.setMargin(20);
	//	controlDock.setTitleBarWidget(&controlDockTitle);
	//	QPointer<QVBoxLayout> dockLayout = new QVBoxLayout();
	//	layoutContainer.setLayout(dockLayout);
	//	controlDock.setWidget(&layoutContainer);
	//	mainWindow.setCentralWidget(vtkRenderWidget);





	//	mapper->SetInputData(polyData);

	//	//vtkNew<vtkActor> actor;
	//	actor->SetMapper(mapper);
	//	actor->GetProperty()->SetColor(colors->GetColor3d("Tomato").GetData());
	//	renderer->SetBackground(namedColors->GetColor3d("black").GetData());
	//	renderWindow->SetWindowName("regular polygon");
	//	renderWindowInteractor->SetRenderWindow(renderWindow);
	//	renderer->AddActor(actor);
	//	renderWindow->SetInteractor(renderWindowInteractor);
	//	renderWindow->AddRenderer(renderer);
	//	renderWindow->SetInteractor(vtkRenderWidget->interactor());
	//	renderWindow->GetInteractor()->SetPicker(pointPicker);
	//	vtkNew<MouseInteractorStylePP> style;
	//	renderWindow->GetInteractor()->SetInteractorStyle(style);
	//	vtkRenderWidget->setRenderWindow(renderWindow);

	//	// Display the regular polygon
	//	renderWindow->Render();
	//	renderWindow->GetInteractor()->Start();
	//	mainWindow.show();

	//	});

	////draw polyline
	//QObject::connect(buttonPolyLine, &QPushButton::clicked, [&]() {
	//	Line = false;
	//	polyL = true;
	//	regpoly = false;

	//	mainWindow.addDockWidget(Qt::LeftDockWidgetArea, &controlDock);

	//	QLabel controlDockTitle("Control Dock");
	//	controlDockTitle.setMargin(20);
	//	controlDock.setTitleBarWidget(&controlDockTitle);

	//	QPointer<QVBoxLayout> dockLayout = new QVBoxLayout();

	//	layoutContainer.setLayout(dockLayout);
	//	controlDock.setWidget(&layoutContainer);


	//	mainWindow.setCentralWidget(vtkRenderWidget);




	//	polyLine->GetPointIds()->SetNumberOfIds(countPolyLinePoints);
	//	for (unsigned int i = 0; i < countPolyLinePoints; i++)
	//	{
	//		polyLine->GetPointIds()->SetId(i, i);
	//	}


	//	cells->InsertNextCell(polyLine);



	//	// Add the points to the dataset
	//	polyData->SetPoints(points);

	//	// Add the lines to the dataset
	//	polyData->SetLines(cells);

	//	// Setup actor and mapper

	//	mapper->SetInputData(polyData);

	//	//vtkNew<vtkActor> actor;
	//	actor->SetMapper(mapper);
	//	actor->GetProperty()->SetColor(colors->GetColor3d("Tomato").GetData());

	//	renderer->SetBackground(namedColors->GetColor3d("SlateGray").GetData());
	//	renderWindow->SetWindowName("PolyLine");

	//	renderWindowInteractor->SetRenderWindow(renderWindow);
	//	renderer->AddActor(actor);




	//	renderWindow->SetInteractor(renderWindowInteractor);


	//	renderWindow->AddRenderer(renderer);
	//	renderWindow->SetInteractor(vtkRenderWidget->interactor());

	//	renderWindow->GetInteractor()->SetPicker(pointPicker);
	//	vtkNew<MouseInteractorStylePP> style;
	//	renderWindow->GetInteractor()->SetInteractorStyle(style);



	//	vtkRenderWidget->setRenderWindow(renderWindow);


	//	// Display the line
	//	renderWindow->Render();


	//	renderWindow->GetInteractor()->Start();


	//	mainWindow.show();

	//	});








		///////////////////////////////////////////////////////////////GUI LINE////////////////////////////////////////////
	mainWindow.addDockWidget(Qt::LeftDockWidgetArea, &controlDock);

	QLabel controlDockTitle("Control Dock");
	controlDockTitle.setMargin(20);
	controlDock.setTitleBarWidget(&controlDockTitle);

	QPointer<QVBoxLayout> dockLayout = new QVBoxLayout();

	layoutContainer.setLayout(dockLayout);
	controlDock.setWidget(&layoutContainer);

	////////////////////////////////////////////////////////////////////END//////////////////////////////////////

	///////////////////////////////////////////////////////////////COMBOBOX COLOUR LINE/////////////////////////////////////////



	color_comboBox->addItem("Black");
	color_comboBox->addItem("White");
	color_comboBox->addItem("Red");
	selectedText = color_comboBox->currentText();

	dockLayout->addWidget(color_comboBox);

	/////////////////////////////////////////////////////////////////END///////////////////////////////////////////////////

	////////////////////////////////////////////////////////SPINBOX LINE WIDTH///////////////////////////////////////
	
	spinBox->setMinimum(0);
	spinBox->setMaximum(100);
	spinBox->setSingleStep(1);
	spinBox->setValue(1);

	dockLayout->addWidget(spinBox);
	///////////////////////////////////////////////////////////////////////////////END/////////////////////////////////
	QComboBox* shape_comboBox = new QComboBox();

	///////////////////////////////////////////////////////////////COMBOBOX COMBOBOX SHAPE SELECT/////////////////////////////////////////
	shape_comboBox->addItem("Line");
	shape_comboBox->addItem("Polyline");
	shape_comboBox->addItem("Polygon");
	shape_comboBox->addItem("Regular Polygon");
	shape_comboBox->addItem("Circle");
	shape_comboBox->addItem("Arc");
	shape_comboBox->addItem("Ellipse");
	dockLayout->addWidget(shape_comboBox);

	QSpinBox* spinNumSides = new QSpinBox();
	QObject::connect(shape_comboBox, (&QComboBox::currentIndexChanged), [&]() {

		string selectedText = shape_comboBox->currentText().toStdString();
		
		switch (selectedText[0]) {
		case 'C':
			if (spinNumSides->value() != NULL) {
				dockLayout->removeWidget(spinNumSides);
			}
			isLine = 0;
			isEllipse = 0;
			isArc = 0;
			isRegularPolygon = 0;
			isPolygon = 0;
			isPolyline = 0;
			isCircle = 1;
			break;
		case 'L':
			if (spinNumSides->value() != NULL) {
				dockLayout->removeWidget(spinNumSides);
			}
			isLine = 1;
			isEllipse = 0;
			isArc = 0;
			isRegularPolygon = 0;
			isPolygon = 0;
			isPolyline = 0;
			isCircle = 0;
			break;

		case 'E':
			if (spinNumSides->value() != NULL) {
				dockLayout->removeWidget(spinNumSides);
			}
			isLine = 0;
			isEllipse = 1;
			isArc = 0;
			isRegularPolygon = 0;
			isPolygon = 0;
			isPolyline = 0;
			isCircle = 0;
			break;
		case 'R':
			isLine = 0;
			isEllipse = 0;
			isArc = 0;
			isRegularPolygon = 1;
			isPolygon = 0;
			isPolyline = 0;
			isCircle = 0;

			
			spinNumSides->setMinimum(0);
			spinNumSides->setMaximum(100);
			spinNumSides->setSingleStep(1);
			spinNumSides->setValue(NumSides);

			dockLayout->addWidget(spinNumSides);
			
			break;
		case 'A':
			if (spinNumSides->value() != NULL) {
				dockLayout->removeWidget(spinNumSides);
			}
			isLine = 0;
			isEllipse = 0;
			isArc = 1;
			isRegularPolygon = 0;
			isPolygon = 0;
			isPolyline = 0;
			isCircle = 0;
			break;
		case 'P':
			if (spinNumSides->value() != NULL) {
				dockLayout->removeWidget(spinNumSides);
			}
			if (selectedText[4] =='l'){
				countIsLine++;
			isLine = 0;
			isEllipse = 0;
			isArc = 0;
			isRegularPolygon = 0;
			isPolygon = 0;
			isPolyline = 1;
			isCircle = 0;
			break;
			}
			else {
				if (spinNumSides->value() != NULL) {
					dockLayout->removeWidget(spinNumSides);
				}
				countIsPolygon++;
				isLine = 0;
				isEllipse = 0;
				isArc = 0;
				isRegularPolygon = 0;
				isPolygon = 1;
				isPolyline = 0;
				isCircle = 0;
				break;
			}
		}

		// update selectedText with the current selected item
		
		



		renderWindow->Render();
		});
	
	///////////////////////////////////////////////////////////////////////////////END/////////////////////////////////

	///////////////////////////////////////////////////////////////////READ WRITE BUTTONS////////////////////////////////////
	QPushButton* pushButton = new QPushButton("Read File");
	QPushButton* pushButton2 = new QPushButton("Write File");
	dockLayout->addWidget(pushButton);
	dockLayout->addWidget(pushButton2);


	mainWindow.setCentralWidget(vtkRenderWidget);


	///////////////////////LINE/////////////////////////////
	

	//Draw_Circle(3);
//	Draw_Arc();
	//Draw_Ellipse();

	mapper->SetInputConnection(lineSource->GetOutputPort());
	mapper->Update();
	actor->GetProperty()->SetColor(colors->GetColor3d(selectedText.toStdString()).GetData());
	/*LineColor = selectedText.toStdString().c_str();
	actor->GetProperty()->SetLineWidth(spinBox->value());*/
	LineWidth = spinBox->value();
	actor->SetMapper(mapper);
	renderer->AddActor(actor);
	renderWindow->AddRenderer(renderer);

	//renderWindow->SetInteractor(renderWindowInteractor);


	/////////////////////////////////////////////////////READ PUSH BUTTON//////////////////////////////////////

	QObject::connect(pushButton, &QPushButton::released, [&]() {

		QString text2 = QInputDialog::getText(nullptr, "Input File Name to be Read", "File Name");
		qDebug() << "Input: " << text2;


		strcpy(read, text2.toStdString().c_str());


		ReadFile(read);
		spinBox->setValue(LineWidth);
		color_comboBox->setCurrentText(LineColor);
		vtkSmartPointer<vtkLineSource> lineSource = vtkSmartPointer<vtkLineSource>::New();
		actor->GetProperty()->SetLineWidth(LineWidth);
		actor->GetProperty()->SetColor(colors->GetColor3d(LineColor).GetData());
		SetFirstPoint();
		SetSecondPoint();
		lineSource->Update();
		cout << picked[1] << "                         " << picked2[1];
		mapper->Update();

		DrawPoint();





		});

	//////////////////////////////////////////////////////////////// END///////////////////////////////
	char test[100] = { 't','e','s','t' };
	ReadFile(test);

	SetFirstPoint();
	SetSecondPoint();

	////////////////////////////////////////////////////////////////WRITE PUSH BUTTON////////////////////////////////
	QObject::connect(pushButton2, &QPushButton::released, [&]() {
		QString text = QInputDialog::getText(nullptr, "Input File Name to be written", "File Name");
		qDebug() << "Input: " << text;
		string write;
		write = text.toStdString();
		write = write + ".txt";
		WriteFile(write);
		});

	//////////////////////////////////////////////////////////////////////END/////////////////////////////////////////////

	////////////////////////////////////////////SET READ VALUES (COLOUR AND WIDTH) IN COMBOBOX AND SPINBOX///////////////
	actor->GetProperty()->SetLineWidth(spinBox->value());
	cout << "color  " << selectedText.toStdString();
	cout << "Linewidth  " << spinBox->value();
	actor->GetProperty()->SetColor(colors->GetColor3d(selectedText.toStdString()).GetData());
	//////////////////////////////////////////////////////////END///////////////////////////////////////////////////////////



	renderer->SetBackground(namedColors->GetColor3d("SlateGray").GetData());
	///////////////////////////////////////////////////////////COMBOBOX WIDGET APPLIED/////////////////////////////////

	QObject::connect(color_comboBox, (&QComboBox::currentIndexChanged), [&]() {


		selectedText = color_comboBox->currentText();


		// update selectedText with the current selected item
		actor->GetProperty()->SetColor(colors->GetColor3d(selectedText.toStdString()).GetData());
		qstrcpy(LineColor, qPrintable(selectedText));



		renderWindow->Render();
		});
	///////////////////////////////////////////////////////////END//////////////////////////////////////////////
	// 
	//////////////////////////////////////////////////////////////////////SPINBOX WIDGET APPLIED///////////////////////////////////
	QObject::connect(spinBox, static_cast<void(QSpinBox::*)(int)>(&QSpinBox::valueChanged), [&]() {
		actor->GetProperty()->SetLineWidth(spinBox->value());
		LineWidth = spinBox->value();
		renderWindow->Render();
		});
	QObject::connect(spinNumSides, static_cast<void(QSpinBox::*)(int)>(&QSpinBox::valueChanged), [&]() {
		
		NumSides = spinNumSides->value();
		Draw_Regular_Polygon();
		renderWindow->Render();
		
		});
	/*QObject::connect(spinStartAngle, static_cast<void(QSpinBox::*)(int)>(&QSpinBox::valueChanged), [&]() {

		startAngle = spinStartAngle->value();
		Draw_Arc;
		renderWindow->Render();

		});
	QObject::connect(spinEndAngle, static_cast<void(QSpinBox::*)(int)>(&QSpinBox::valueChanged), [&]() {

		endAngle = spinEndAngle->value();
		Draw_Arc;
		renderWindow->Render();

		});*/
	////////////////////////////////////////////////////////////////////////////END/////////////////////////////

	///////////////////////////////////////////////RENDERING, RENDERER, RENDERWINDOW, INTERACTOR//////////////////
	//Connect renderWindowInteractor in ONLeftClick with current working interactor
	// 
	// 

	renderWindow->SetInteractor(renderWindowInteractor);


	renderWindow->AddRenderer(renderer);
	renderWindow->SetInteractor(vtkRenderWidget->interactor());

	renderWindow->GetInteractor()->SetPicker(pointPicker);
	vtkNew<MouseInteractorStylePP> style;
	renderWindow->GetInteractor()->SetInteractorStyle(style);



	vtkRenderWidget->setRenderWindow(renderWindow);


	// Display the line
	renderWindow->Render();


	renderWindow->GetInteractor()->Start();


	mainWindow.show();



	mainWindow.show();

	return app.exec();


}
